/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.7.1
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// DestinyDefinitionsDestinyLocationReleaseDefinition : A specific \"spot\" referred to by a location. Only one of these can be active at a time for a given Location.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct DestinyDefinitionsDestinyLocationReleaseDefinition {
  /// Sadly, these don't appear to be populated anymore (ever?)
  #[serde(rename = "displayProperties")]
  display_properties: Option<Value>,
  #[serde(rename = "smallTransparentIcon")]
  small_transparent_icon: Option<String>,
  #[serde(rename = "mapIcon")]
  map_icon: Option<String>,
  #[serde(rename = "largeTransparentIcon")]
  large_transparent_icon: Option<String>,
  /// If we had map information, this spawnPoint would be interesting. But sadly, we don't have that info.
  #[serde(rename = "spawnPoint")]
  spawn_point: Option<i32>,
  /// The Destination being pointed to by this location.
  #[serde(rename = "destinationHash")]
  destination_hash: Option<i32>,
  /// The Activity being pointed to by this location.
  #[serde(rename = "activityHash")]
  activity_hash: Option<i32>,
  /// The Activity Graph being pointed to by this location.
  #[serde(rename = "activityGraphHash")]
  activity_graph_hash: Option<i32>,
  /// The Activity Graph Node being pointed to by this location. (Remember that Activity Graph Node hashes are only unique within an Activity Graph: so use the combination to find the node being spoken of)
  #[serde(rename = "activityGraphNodeHash")]
  activity_graph_node_hash: Option<i32>,
  /// The Activity Bubble within the Destination. Look this up in the DestinyDestinationDefinition's bubbles and bubbleSettings properties.
  #[serde(rename = "activityBubbleName")]
  activity_bubble_name: Option<i32>,
  /// If we had map information, this would tell us something cool about the path this location wants you to take. I wish we had map information.
  #[serde(rename = "activityPathBundle")]
  activity_path_bundle: Option<i32>,
  /// If we had map information, this would tell us about path information related to destination on the map. Sad. Maybe you can do something cool with it. Go to town man.
  #[serde(rename = "activityPathDestination")]
  activity_path_destination: Option<i32>,
  /// The type of Nav Point that this represents. See the enumeration for more info.
  #[serde(rename = "navPointType")]
  nav_point_type: Option<i32>,
  /// Looks like it should be the position on the map, but sadly it does not look populated... yet?
  #[serde(rename = "worldPosition")]
  world_position: Option<Vec<i32>>
}

impl DestinyDefinitionsDestinyLocationReleaseDefinition {
  /// A specific \"spot\" referred to by a location. Only one of these can be active at a time for a given Location.
  pub fn new() -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    DestinyDefinitionsDestinyLocationReleaseDefinition {
      display_properties: None,
      small_transparent_icon: None,
      map_icon: None,
      large_transparent_icon: None,
      spawn_point: None,
      destination_hash: None,
      activity_hash: None,
      activity_graph_hash: None,
      activity_graph_node_hash: None,
      activity_bubble_name: None,
      activity_path_bundle: None,
      activity_path_destination: None,
      nav_point_type: None,
      world_position: None
    }
  }

  pub fn set_display_properties(&mut self, display_properties: Value) {
    self.display_properties = Some(display_properties);
  }

  pub fn with_display_properties(mut self, display_properties: Value) -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    self.display_properties = Some(display_properties);
    self
  }

  pub fn display_properties(&self) -> Option<&Value> {
    self.display_properties.as_ref()
  }

  pub fn reset_display_properties(&mut self) {
    self.display_properties = None;
  }

  pub fn set_small_transparent_icon(&mut self, small_transparent_icon: String) {
    self.small_transparent_icon = Some(small_transparent_icon);
  }

  pub fn with_small_transparent_icon(mut self, small_transparent_icon: String) -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    self.small_transparent_icon = Some(small_transparent_icon);
    self
  }

  pub fn small_transparent_icon(&self) -> Option<&String> {
    self.small_transparent_icon.as_ref()
  }

  pub fn reset_small_transparent_icon(&mut self) {
    self.small_transparent_icon = None;
  }

  pub fn set_map_icon(&mut self, map_icon: String) {
    self.map_icon = Some(map_icon);
  }

  pub fn with_map_icon(mut self, map_icon: String) -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    self.map_icon = Some(map_icon);
    self
  }

  pub fn map_icon(&self) -> Option<&String> {
    self.map_icon.as_ref()
  }

  pub fn reset_map_icon(&mut self) {
    self.map_icon = None;
  }

  pub fn set_large_transparent_icon(&mut self, large_transparent_icon: String) {
    self.large_transparent_icon = Some(large_transparent_icon);
  }

  pub fn with_large_transparent_icon(mut self, large_transparent_icon: String) -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    self.large_transparent_icon = Some(large_transparent_icon);
    self
  }

  pub fn large_transparent_icon(&self) -> Option<&String> {
    self.large_transparent_icon.as_ref()
  }

  pub fn reset_large_transparent_icon(&mut self) {
    self.large_transparent_icon = None;
  }

  pub fn set_spawn_point(&mut self, spawn_point: i32) {
    self.spawn_point = Some(spawn_point);
  }

  pub fn with_spawn_point(mut self, spawn_point: i32) -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    self.spawn_point = Some(spawn_point);
    self
  }

  pub fn spawn_point(&self) -> Option<&i32> {
    self.spawn_point.as_ref()
  }

  pub fn reset_spawn_point(&mut self) {
    self.spawn_point = None;
  }

  pub fn set_destination_hash(&mut self, destination_hash: i32) {
    self.destination_hash = Some(destination_hash);
  }

  pub fn with_destination_hash(mut self, destination_hash: i32) -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    self.destination_hash = Some(destination_hash);
    self
  }

  pub fn destination_hash(&self) -> Option<&i32> {
    self.destination_hash.as_ref()
  }

  pub fn reset_destination_hash(&mut self) {
    self.destination_hash = None;
  }

  pub fn set_activity_hash(&mut self, activity_hash: i32) {
    self.activity_hash = Some(activity_hash);
  }

  pub fn with_activity_hash(mut self, activity_hash: i32) -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    self.activity_hash = Some(activity_hash);
    self
  }

  pub fn activity_hash(&self) -> Option<&i32> {
    self.activity_hash.as_ref()
  }

  pub fn reset_activity_hash(&mut self) {
    self.activity_hash = None;
  }

  pub fn set_activity_graph_hash(&mut self, activity_graph_hash: i32) {
    self.activity_graph_hash = Some(activity_graph_hash);
  }

  pub fn with_activity_graph_hash(mut self, activity_graph_hash: i32) -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    self.activity_graph_hash = Some(activity_graph_hash);
    self
  }

  pub fn activity_graph_hash(&self) -> Option<&i32> {
    self.activity_graph_hash.as_ref()
  }

  pub fn reset_activity_graph_hash(&mut self) {
    self.activity_graph_hash = None;
  }

  pub fn set_activity_graph_node_hash(&mut self, activity_graph_node_hash: i32) {
    self.activity_graph_node_hash = Some(activity_graph_node_hash);
  }

  pub fn with_activity_graph_node_hash(mut self, activity_graph_node_hash: i32) -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    self.activity_graph_node_hash = Some(activity_graph_node_hash);
    self
  }

  pub fn activity_graph_node_hash(&self) -> Option<&i32> {
    self.activity_graph_node_hash.as_ref()
  }

  pub fn reset_activity_graph_node_hash(&mut self) {
    self.activity_graph_node_hash = None;
  }

  pub fn set_activity_bubble_name(&mut self, activity_bubble_name: i32) {
    self.activity_bubble_name = Some(activity_bubble_name);
  }

  pub fn with_activity_bubble_name(mut self, activity_bubble_name: i32) -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    self.activity_bubble_name = Some(activity_bubble_name);
    self
  }

  pub fn activity_bubble_name(&self) -> Option<&i32> {
    self.activity_bubble_name.as_ref()
  }

  pub fn reset_activity_bubble_name(&mut self) {
    self.activity_bubble_name = None;
  }

  pub fn set_activity_path_bundle(&mut self, activity_path_bundle: i32) {
    self.activity_path_bundle = Some(activity_path_bundle);
  }

  pub fn with_activity_path_bundle(mut self, activity_path_bundle: i32) -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    self.activity_path_bundle = Some(activity_path_bundle);
    self
  }

  pub fn activity_path_bundle(&self) -> Option<&i32> {
    self.activity_path_bundle.as_ref()
  }

  pub fn reset_activity_path_bundle(&mut self) {
    self.activity_path_bundle = None;
  }

  pub fn set_activity_path_destination(&mut self, activity_path_destination: i32) {
    self.activity_path_destination = Some(activity_path_destination);
  }

  pub fn with_activity_path_destination(mut self, activity_path_destination: i32) -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    self.activity_path_destination = Some(activity_path_destination);
    self
  }

  pub fn activity_path_destination(&self) -> Option<&i32> {
    self.activity_path_destination.as_ref()
  }

  pub fn reset_activity_path_destination(&mut self) {
    self.activity_path_destination = None;
  }

  pub fn set_nav_point_type(&mut self, nav_point_type: i32) {
    self.nav_point_type = Some(nav_point_type);
  }

  pub fn with_nav_point_type(mut self, nav_point_type: i32) -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    self.nav_point_type = Some(nav_point_type);
    self
  }

  pub fn nav_point_type(&self) -> Option<&i32> {
    self.nav_point_type.as_ref()
  }

  pub fn reset_nav_point_type(&mut self) {
    self.nav_point_type = None;
  }

  pub fn set_world_position(&mut self, world_position: Vec<i32>) {
    self.world_position = Some(world_position);
  }

  pub fn with_world_position(mut self, world_position: Vec<i32>) -> DestinyDefinitionsDestinyLocationReleaseDefinition {
    self.world_position = Some(world_position);
    self
  }

  pub fn world_position(&self) -> Option<&Vec<i32>> {
    self.world_position.as_ref()
  }

  pub fn reset_world_position(&mut self) {
    self.world_position = None;
  }

}



