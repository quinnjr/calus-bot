/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.7.1
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// DestinyHistoricalStatsDestinyHistoricalStatsActivity : Summary information about the activity that was played.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct DestinyHistoricalStatsDestinyHistoricalStatsActivity {
  /// The unique hash identifier of the DestinyActivityDefinition that was played. If I had this to do over, it'd be named activityHash. Too late now.
  #[serde(rename = "referenceId")]
  reference_id: Option<i32>,
  /// The unique hash identifier of the DestinyActivityDefinition that was played.
  #[serde(rename = "directorActivityHash")]
  director_activity_hash: Option<i32>,
  /// The unique identifier for this *specific* match that was played.  This value can be used to get additional data about this activity such as who else was playing via the GetPostGameCarnageReport endpoint.
  #[serde(rename = "instanceId")]
  instance_id: Option<i64>,
  /// Indicates the most specific game mode of the activity that we could find.
  #[serde(rename = "mode")]
  mode: Option<i32>,
  /// The list of all Activity Modes to which this activity applies, including aggregates. This will let you see, for example, whether the activity was both Clash and part of the Trials of the Nine event.
  #[serde(rename = "modes")]
  modes: Option<Vec<i32>>,
  /// Whether or not the match was a private match.
  #[serde(rename = "isPrivate")]
  is_private: Option<bool>,
  /// The Membership Type indicating the platform on which this match was played.
  #[serde(rename = "membershipType")]
  membership_type: Option<i32>
}

impl DestinyHistoricalStatsDestinyHistoricalStatsActivity {
  /// Summary information about the activity that was played.
  pub fn new() -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    DestinyHistoricalStatsDestinyHistoricalStatsActivity {
      reference_id: None,
      director_activity_hash: None,
      instance_id: None,
      mode: None,
      modes: None,
      is_private: None,
      membership_type: None
    }
  }

  pub fn set_reference_id(&mut self, reference_id: i32) {
    self.reference_id = Some(reference_id);
  }

  pub fn with_reference_id(mut self, reference_id: i32) -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    self.reference_id = Some(reference_id);
    self
  }

  pub fn reference_id(&self) -> Option<&i32> {
    self.reference_id.as_ref()
  }

  pub fn reset_reference_id(&mut self) {
    self.reference_id = None;
  }

  pub fn set_director_activity_hash(&mut self, director_activity_hash: i32) {
    self.director_activity_hash = Some(director_activity_hash);
  }

  pub fn with_director_activity_hash(mut self, director_activity_hash: i32) -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    self.director_activity_hash = Some(director_activity_hash);
    self
  }

  pub fn director_activity_hash(&self) -> Option<&i32> {
    self.director_activity_hash.as_ref()
  }

  pub fn reset_director_activity_hash(&mut self) {
    self.director_activity_hash = None;
  }

  pub fn set_instance_id(&mut self, instance_id: i64) {
    self.instance_id = Some(instance_id);
  }

  pub fn with_instance_id(mut self, instance_id: i64) -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    self.instance_id = Some(instance_id);
    self
  }

  pub fn instance_id(&self) -> Option<&i64> {
    self.instance_id.as_ref()
  }

  pub fn reset_instance_id(&mut self) {
    self.instance_id = None;
  }

  pub fn set_mode(&mut self, mode: i32) {
    self.mode = Some(mode);
  }

  pub fn with_mode(mut self, mode: i32) -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    self.mode = Some(mode);
    self
  }

  pub fn mode(&self) -> Option<&i32> {
    self.mode.as_ref()
  }

  pub fn reset_mode(&mut self) {
    self.mode = None;
  }

  pub fn set_modes(&mut self, modes: Vec<i32>) {
    self.modes = Some(modes);
  }

  pub fn with_modes(mut self, modes: Vec<i32>) -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    self.modes = Some(modes);
    self
  }

  pub fn modes(&self) -> Option<&Vec<i32>> {
    self.modes.as_ref()
  }

  pub fn reset_modes(&mut self) {
    self.modes = None;
  }

  pub fn set_is_private(&mut self, is_private: bool) {
    self.is_private = Some(is_private);
  }

  pub fn with_is_private(mut self, is_private: bool) -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    self.is_private = Some(is_private);
    self
  }

  pub fn is_private(&self) -> Option<&bool> {
    self.is_private.as_ref()
  }

  pub fn reset_is_private(&mut self) {
    self.is_private = None;
  }

  pub fn set_membership_type(&mut self, membership_type: i32) {
    self.membership_type = Some(membership_type);
  }

  pub fn with_membership_type(mut self, membership_type: i32) -> DestinyHistoricalStatsDestinyHistoricalStatsActivity {
    self.membership_type = Some(membership_type);
    self
  }

  pub fn membership_type(&self) -> Option<&i32> {
    self.membership_type.as_ref()
  }

  pub fn reset_membership_type(&mut self) {
    self.membership_type = None;
  }

}



