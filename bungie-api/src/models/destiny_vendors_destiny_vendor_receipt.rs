/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.7.1
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// DestinyVendorsDestinyVendorReceipt : If a character purchased an item that is refundable, a Vendor Receipt will be created on the user's Destiny Profile. These expire after a configurable period of time, but until then can be used to get refunds on items. BNet does not provide the ability to refund a purchase *yet*, but you know.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct DestinyVendorsDestinyVendorReceipt {
  /// The amount paid for the item, in terms of items that were consumed in the purchase and their quantity.
  #[serde(rename = "currencyPaid")]
  currency_paid: Option<Vec<::models::DestinyDestinyItemQuantity>>,
  /// The item that was received, and its quantity.
  #[serde(rename = "itemReceived")]
  item_received: Option<Value>,
  /// The unlock flag used to determine whether you still have the purchased item.
  #[serde(rename = "licenseUnlockHash")]
  license_unlock_hash: Option<i32>,
  /// The ID of the character who made the purchase.
  #[serde(rename = "purchasedByCharacterId")]
  purchased_by_character_id: Option<i64>,
  /// Whether you can get a refund, and what happens in order for the refund to be received. See the DestinyVendorItemRefundPolicy enum for details.
  #[serde(rename = "refundPolicy")]
  refund_policy: Option<i32>,
  /// The identifier of this receipt.
  #[serde(rename = "sequenceNumber")]
  sequence_number: Option<i32>,
  /// The seconds since epoch at which this receipt is rendered invalid.
  #[serde(rename = "timeToExpiration")]
  time_to_expiration: Option<i64>,
  /// The date at which this receipt is rendered invalid.
  #[serde(rename = "expiresOn")]
  expires_on: Option<String>
}

impl DestinyVendorsDestinyVendorReceipt {
  /// If a character purchased an item that is refundable, a Vendor Receipt will be created on the user's Destiny Profile. These expire after a configurable period of time, but until then can be used to get refunds on items. BNet does not provide the ability to refund a purchase *yet*, but you know.
  pub fn new() -> DestinyVendorsDestinyVendorReceipt {
    DestinyVendorsDestinyVendorReceipt {
      currency_paid: None,
      item_received: None,
      license_unlock_hash: None,
      purchased_by_character_id: None,
      refund_policy: None,
      sequence_number: None,
      time_to_expiration: None,
      expires_on: None
    }
  }

  pub fn set_currency_paid(&mut self, currency_paid: Vec<::models::DestinyDestinyItemQuantity>) {
    self.currency_paid = Some(currency_paid);
  }

  pub fn with_currency_paid(mut self, currency_paid: Vec<::models::DestinyDestinyItemQuantity>) -> DestinyVendorsDestinyVendorReceipt {
    self.currency_paid = Some(currency_paid);
    self
  }

  pub fn currency_paid(&self) -> Option<&Vec<::models::DestinyDestinyItemQuantity>> {
    self.currency_paid.as_ref()
  }

  pub fn reset_currency_paid(&mut self) {
    self.currency_paid = None;
  }

  pub fn set_item_received(&mut self, item_received: Value) {
    self.item_received = Some(item_received);
  }

  pub fn with_item_received(mut self, item_received: Value) -> DestinyVendorsDestinyVendorReceipt {
    self.item_received = Some(item_received);
    self
  }

  pub fn item_received(&self) -> Option<&Value> {
    self.item_received.as_ref()
  }

  pub fn reset_item_received(&mut self) {
    self.item_received = None;
  }

  pub fn set_license_unlock_hash(&mut self, license_unlock_hash: i32) {
    self.license_unlock_hash = Some(license_unlock_hash);
  }

  pub fn with_license_unlock_hash(mut self, license_unlock_hash: i32) -> DestinyVendorsDestinyVendorReceipt {
    self.license_unlock_hash = Some(license_unlock_hash);
    self
  }

  pub fn license_unlock_hash(&self) -> Option<&i32> {
    self.license_unlock_hash.as_ref()
  }

  pub fn reset_license_unlock_hash(&mut self) {
    self.license_unlock_hash = None;
  }

  pub fn set_purchased_by_character_id(&mut self, purchased_by_character_id: i64) {
    self.purchased_by_character_id = Some(purchased_by_character_id);
  }

  pub fn with_purchased_by_character_id(mut self, purchased_by_character_id: i64) -> DestinyVendorsDestinyVendorReceipt {
    self.purchased_by_character_id = Some(purchased_by_character_id);
    self
  }

  pub fn purchased_by_character_id(&self) -> Option<&i64> {
    self.purchased_by_character_id.as_ref()
  }

  pub fn reset_purchased_by_character_id(&mut self) {
    self.purchased_by_character_id = None;
  }

  pub fn set_refund_policy(&mut self, refund_policy: i32) {
    self.refund_policy = Some(refund_policy);
  }

  pub fn with_refund_policy(mut self, refund_policy: i32) -> DestinyVendorsDestinyVendorReceipt {
    self.refund_policy = Some(refund_policy);
    self
  }

  pub fn refund_policy(&self) -> Option<&i32> {
    self.refund_policy.as_ref()
  }

  pub fn reset_refund_policy(&mut self) {
    self.refund_policy = None;
  }

  pub fn set_sequence_number(&mut self, sequence_number: i32) {
    self.sequence_number = Some(sequence_number);
  }

  pub fn with_sequence_number(mut self, sequence_number: i32) -> DestinyVendorsDestinyVendorReceipt {
    self.sequence_number = Some(sequence_number);
    self
  }

  pub fn sequence_number(&self) -> Option<&i32> {
    self.sequence_number.as_ref()
  }

  pub fn reset_sequence_number(&mut self) {
    self.sequence_number = None;
  }

  pub fn set_time_to_expiration(&mut self, time_to_expiration: i64) {
    self.time_to_expiration = Some(time_to_expiration);
  }

  pub fn with_time_to_expiration(mut self, time_to_expiration: i64) -> DestinyVendorsDestinyVendorReceipt {
    self.time_to_expiration = Some(time_to_expiration);
    self
  }

  pub fn time_to_expiration(&self) -> Option<&i64> {
    self.time_to_expiration.as_ref()
  }

  pub fn reset_time_to_expiration(&mut self) {
    self.time_to_expiration = None;
  }

  pub fn set_expires_on(&mut self, expires_on: String) {
    self.expires_on = Some(expires_on);
  }

  pub fn with_expires_on(mut self, expires_on: String) -> DestinyVendorsDestinyVendorReceipt {
    self.expires_on = Some(expires_on);
    self
  }

  pub fn expires_on(&self) -> Option<&String> {
    self.expires_on.as_ref()
  }

  pub fn reset_expires_on(&mut self) {
    self.expires_on = None;
  }

}



