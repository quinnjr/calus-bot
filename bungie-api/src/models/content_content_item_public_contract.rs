/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.7.1
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ContentContentItemPublicContract {
  #[serde(rename = "contentId")]
  content_id: Option<i64>,
  #[serde(rename = "cType")]
  c_type: Option<String>,
  #[serde(rename = "cmsPath")]
  cms_path: Option<String>,
  #[serde(rename = "creationDate")]
  creation_date: Option<String>,
  #[serde(rename = "modifyDate")]
  modify_date: Option<String>,
  #[serde(rename = "allowComments")]
  allow_comments: Option<bool>,
  #[serde(rename = "hasAgeGate")]
  has_age_gate: Option<bool>,
  #[serde(rename = "minimumAge")]
  minimum_age: Option<i32>,
  #[serde(rename = "ratingImagePath")]
  rating_image_path: Option<String>,
  #[serde(rename = "author")]
  author: Option<::models::UserGeneralUser>,
  #[serde(rename = "autoEnglishPropertyFallback")]
  auto_english_property_fallback: Option<bool>,
  /// Firehose content is really a collection of metadata and \"properties\", which are the potentially-but-not-strictly localizable data that comprises the meat of whatever content is being shown.  As Cole Porter would have crooned, \"Anything Goes\" with Firehose properties. They are most often strings, but they can theoretically be anything. They are JSON encoded, and could be JSON structures, simple strings, numbers etc... The Content Type of the item (cType) will describe the properties, and thus how they ought to be deserialized.
  #[serde(rename = "properties")]
  properties: Option<::std::collections::HashMap<String, Value>>,
  #[serde(rename = "representations")]
  representations: Option<Vec<::models::ContentContentRepresentation>>,
  /// NOTE: Tags will always be lower case.
  #[serde(rename = "tags")]
  tags: Option<Vec<String>>,
  #[serde(rename = "commentSummary")]
  comment_summary: Option<::models::ContentCommentSummary>
}

impl ContentContentItemPublicContract {
  pub fn new() -> ContentContentItemPublicContract {
    ContentContentItemPublicContract {
      content_id: None,
      c_type: None,
      cms_path: None,
      creation_date: None,
      modify_date: None,
      allow_comments: None,
      has_age_gate: None,
      minimum_age: None,
      rating_image_path: None,
      author: None,
      auto_english_property_fallback: None,
      properties: None,
      representations: None,
      tags: None,
      comment_summary: None
    }
  }

  pub fn set_content_id(&mut self, content_id: i64) {
    self.content_id = Some(content_id);
  }

  pub fn with_content_id(mut self, content_id: i64) -> ContentContentItemPublicContract {
    self.content_id = Some(content_id);
    self
  }

  pub fn content_id(&self) -> Option<&i64> {
    self.content_id.as_ref()
  }

  pub fn reset_content_id(&mut self) {
    self.content_id = None;
  }

  pub fn set_c_type(&mut self, c_type: String) {
    self.c_type = Some(c_type);
  }

  pub fn with_c_type(mut self, c_type: String) -> ContentContentItemPublicContract {
    self.c_type = Some(c_type);
    self
  }

  pub fn c_type(&self) -> Option<&String> {
    self.c_type.as_ref()
  }

  pub fn reset_c_type(&mut self) {
    self.c_type = None;
  }

  pub fn set_cms_path(&mut self, cms_path: String) {
    self.cms_path = Some(cms_path);
  }

  pub fn with_cms_path(mut self, cms_path: String) -> ContentContentItemPublicContract {
    self.cms_path = Some(cms_path);
    self
  }

  pub fn cms_path(&self) -> Option<&String> {
    self.cms_path.as_ref()
  }

  pub fn reset_cms_path(&mut self) {
    self.cms_path = None;
  }

  pub fn set_creation_date(&mut self, creation_date: String) {
    self.creation_date = Some(creation_date);
  }

  pub fn with_creation_date(mut self, creation_date: String) -> ContentContentItemPublicContract {
    self.creation_date = Some(creation_date);
    self
  }

  pub fn creation_date(&self) -> Option<&String> {
    self.creation_date.as_ref()
  }

  pub fn reset_creation_date(&mut self) {
    self.creation_date = None;
  }

  pub fn set_modify_date(&mut self, modify_date: String) {
    self.modify_date = Some(modify_date);
  }

  pub fn with_modify_date(mut self, modify_date: String) -> ContentContentItemPublicContract {
    self.modify_date = Some(modify_date);
    self
  }

  pub fn modify_date(&self) -> Option<&String> {
    self.modify_date.as_ref()
  }

  pub fn reset_modify_date(&mut self) {
    self.modify_date = None;
  }

  pub fn set_allow_comments(&mut self, allow_comments: bool) {
    self.allow_comments = Some(allow_comments);
  }

  pub fn with_allow_comments(mut self, allow_comments: bool) -> ContentContentItemPublicContract {
    self.allow_comments = Some(allow_comments);
    self
  }

  pub fn allow_comments(&self) -> Option<&bool> {
    self.allow_comments.as_ref()
  }

  pub fn reset_allow_comments(&mut self) {
    self.allow_comments = None;
  }

  pub fn set_has_age_gate(&mut self, has_age_gate: bool) {
    self.has_age_gate = Some(has_age_gate);
  }

  pub fn with_has_age_gate(mut self, has_age_gate: bool) -> ContentContentItemPublicContract {
    self.has_age_gate = Some(has_age_gate);
    self
  }

  pub fn has_age_gate(&self) -> Option<&bool> {
    self.has_age_gate.as_ref()
  }

  pub fn reset_has_age_gate(&mut self) {
    self.has_age_gate = None;
  }

  pub fn set_minimum_age(&mut self, minimum_age: i32) {
    self.minimum_age = Some(minimum_age);
  }

  pub fn with_minimum_age(mut self, minimum_age: i32) -> ContentContentItemPublicContract {
    self.minimum_age = Some(minimum_age);
    self
  }

  pub fn minimum_age(&self) -> Option<&i32> {
    self.minimum_age.as_ref()
  }

  pub fn reset_minimum_age(&mut self) {
    self.minimum_age = None;
  }

  pub fn set_rating_image_path(&mut self, rating_image_path: String) {
    self.rating_image_path = Some(rating_image_path);
  }

  pub fn with_rating_image_path(mut self, rating_image_path: String) -> ContentContentItemPublicContract {
    self.rating_image_path = Some(rating_image_path);
    self
  }

  pub fn rating_image_path(&self) -> Option<&String> {
    self.rating_image_path.as_ref()
  }

  pub fn reset_rating_image_path(&mut self) {
    self.rating_image_path = None;
  }

  pub fn set_author(&mut self, author: ::models::UserGeneralUser) {
    self.author = Some(author);
  }

  pub fn with_author(mut self, author: ::models::UserGeneralUser) -> ContentContentItemPublicContract {
    self.author = Some(author);
    self
  }

  pub fn author(&self) -> Option<&::models::UserGeneralUser> {
    self.author.as_ref()
  }

  pub fn reset_author(&mut self) {
    self.author = None;
  }

  pub fn set_auto_english_property_fallback(&mut self, auto_english_property_fallback: bool) {
    self.auto_english_property_fallback = Some(auto_english_property_fallback);
  }

  pub fn with_auto_english_property_fallback(mut self, auto_english_property_fallback: bool) -> ContentContentItemPublicContract {
    self.auto_english_property_fallback = Some(auto_english_property_fallback);
    self
  }

  pub fn auto_english_property_fallback(&self) -> Option<&bool> {
    self.auto_english_property_fallback.as_ref()
  }

  pub fn reset_auto_english_property_fallback(&mut self) {
    self.auto_english_property_fallback = None;
  }

  pub fn set_properties(&mut self, properties: ::std::collections::HashMap<String, Value>) {
    self.properties = Some(properties);
  }

  pub fn with_properties(mut self, properties: ::std::collections::HashMap<String, Value>) -> ContentContentItemPublicContract {
    self.properties = Some(properties);
    self
  }

  pub fn properties(&self) -> Option<&::std::collections::HashMap<String, Value>> {
    self.properties.as_ref()
  }

  pub fn reset_properties(&mut self) {
    self.properties = None;
  }

  pub fn set_representations(&mut self, representations: Vec<::models::ContentContentRepresentation>) {
    self.representations = Some(representations);
  }

  pub fn with_representations(mut self, representations: Vec<::models::ContentContentRepresentation>) -> ContentContentItemPublicContract {
    self.representations = Some(representations);
    self
  }

  pub fn representations(&self) -> Option<&Vec<::models::ContentContentRepresentation>> {
    self.representations.as_ref()
  }

  pub fn reset_representations(&mut self) {
    self.representations = None;
  }

  pub fn set_tags(&mut self, tags: Vec<String>) {
    self.tags = Some(tags);
  }

  pub fn with_tags(mut self, tags: Vec<String>) -> ContentContentItemPublicContract {
    self.tags = Some(tags);
    self
  }

  pub fn tags(&self) -> Option<&Vec<String>> {
    self.tags.as_ref()
  }

  pub fn reset_tags(&mut self) {
    self.tags = None;
  }

  pub fn set_comment_summary(&mut self, comment_summary: ::models::ContentCommentSummary) {
    self.comment_summary = Some(comment_summary);
  }

  pub fn with_comment_summary(mut self, comment_summary: ::models::ContentCommentSummary) -> ContentContentItemPublicContract {
    self.comment_summary = Some(comment_summary);
    self
  }

  pub fn comment_summary(&self) -> Option<&::models::ContentCommentSummary> {
    self.comment_summary.as_ref()
  }

  pub fn reset_comment_summary(&mut self) {
    self.comment_summary = None;
  }

}



