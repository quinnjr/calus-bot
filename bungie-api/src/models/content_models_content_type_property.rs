/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.7.1
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ContentModelsContentTypeProperty {
  #[serde(rename = "name")]
  name: Option<String>,
  #[serde(rename = "rootPropertyName")]
  root_property_name: Option<String>,
  #[serde(rename = "readableName")]
  readable_name: Option<String>,
  #[serde(rename = "value")]
  value: Option<String>,
  #[serde(rename = "propertyDescription")]
  property_description: Option<String>,
  #[serde(rename = "localizable")]
  localizable: Option<bool>,
  #[serde(rename = "fallback")]
  fallback: Option<bool>,
  #[serde(rename = "enabled")]
  enabled: Option<bool>,
  #[serde(rename = "order")]
  order: Option<i32>,
  #[serde(rename = "visible")]
  visible: Option<bool>,
  #[serde(rename = "isTitle")]
  is_title: Option<bool>,
  #[serde(rename = "required")]
  required: Option<bool>,
  #[serde(rename = "maxLength")]
  max_length: Option<i32>,
  #[serde(rename = "maxByteLength")]
  max_byte_length: Option<i32>,
  #[serde(rename = "maxFileSize")]
  max_file_size: Option<i32>,
  #[serde(rename = "regexp")]
  regexp: Option<String>,
  #[serde(rename = "validateAs")]
  validate_as: Option<String>,
  #[serde(rename = "rssAttribute")]
  rss_attribute: Option<String>,
  #[serde(rename = "visibleDependency")]
  visible_dependency: Option<String>,
  #[serde(rename = "visibleOn")]
  visible_on: Option<String>,
  #[serde(rename = "datatype")]
  datatype: Option<i32>,
  #[serde(rename = "attributes")]
  attributes: Option<::std::collections::HashMap<String, String>>,
  #[serde(rename = "childProperties")]
  child_properties: Option<Vec<::models::ContentModelsContentTypeProperty>>,
  #[serde(rename = "contentTypeAllowed")]
  content_type_allowed: Option<String>,
  #[serde(rename = "bindToProperty")]
  bind_to_property: Option<String>,
  #[serde(rename = "boundRegex")]
  bound_regex: Option<String>,
  #[serde(rename = "representationSelection")]
  representation_selection: Option<::std::collections::HashMap<String, String>>,
  #[serde(rename = "defaultValues")]
  default_values: Option<Vec<::models::ContentModelsContentTypeDefaultValue>>,
  #[serde(rename = "isExternalAllowed")]
  is_external_allowed: Option<bool>,
  #[serde(rename = "propertySection")]
  property_section: Option<String>,
  #[serde(rename = "weight")]
  weight: Option<i32>,
  #[serde(rename = "entitytype")]
  entitytype: Option<String>,
  #[serde(rename = "isCombo")]
  is_combo: Option<bool>,
  #[serde(rename = "suppressProperty")]
  suppress_property: Option<bool>,
  #[serde(rename = "legalContentTypes")]
  legal_content_types: Option<Vec<String>>,
  #[serde(rename = "representationValidationString")]
  representation_validation_string: Option<String>,
  #[serde(rename = "minWidth")]
  min_width: Option<i32>,
  #[serde(rename = "maxWidth")]
  max_width: Option<i32>,
  #[serde(rename = "minHeight")]
  min_height: Option<i32>,
  #[serde(rename = "maxHeight")]
  max_height: Option<i32>,
  #[serde(rename = "isVideo")]
  is_video: Option<bool>,
  #[serde(rename = "isImage")]
  is_image: Option<bool>
}

impl ContentModelsContentTypeProperty {
  pub fn new() -> ContentModelsContentTypeProperty {
    ContentModelsContentTypeProperty {
      name: None,
      root_property_name: None,
      readable_name: None,
      value: None,
      property_description: None,
      localizable: None,
      fallback: None,
      enabled: None,
      order: None,
      visible: None,
      is_title: None,
      required: None,
      max_length: None,
      max_byte_length: None,
      max_file_size: None,
      regexp: None,
      validate_as: None,
      rss_attribute: None,
      visible_dependency: None,
      visible_on: None,
      datatype: None,
      attributes: None,
      child_properties: None,
      content_type_allowed: None,
      bind_to_property: None,
      bound_regex: None,
      representation_selection: None,
      default_values: None,
      is_external_allowed: None,
      property_section: None,
      weight: None,
      entitytype: None,
      is_combo: None,
      suppress_property: None,
      legal_content_types: None,
      representation_validation_string: None,
      min_width: None,
      max_width: None,
      min_height: None,
      max_height: None,
      is_video: None,
      is_image: None
    }
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> ContentModelsContentTypeProperty {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_root_property_name(&mut self, root_property_name: String) {
    self.root_property_name = Some(root_property_name);
  }

  pub fn with_root_property_name(mut self, root_property_name: String) -> ContentModelsContentTypeProperty {
    self.root_property_name = Some(root_property_name);
    self
  }

  pub fn root_property_name(&self) -> Option<&String> {
    self.root_property_name.as_ref()
  }

  pub fn reset_root_property_name(&mut self) {
    self.root_property_name = None;
  }

  pub fn set_readable_name(&mut self, readable_name: String) {
    self.readable_name = Some(readable_name);
  }

  pub fn with_readable_name(mut self, readable_name: String) -> ContentModelsContentTypeProperty {
    self.readable_name = Some(readable_name);
    self
  }

  pub fn readable_name(&self) -> Option<&String> {
    self.readable_name.as_ref()
  }

  pub fn reset_readable_name(&mut self) {
    self.readable_name = None;
  }

  pub fn set_value(&mut self, value: String) {
    self.value = Some(value);
  }

  pub fn with_value(mut self, value: String) -> ContentModelsContentTypeProperty {
    self.value = Some(value);
    self
  }

  pub fn value(&self) -> Option<&String> {
    self.value.as_ref()
  }

  pub fn reset_value(&mut self) {
    self.value = None;
  }

  pub fn set_property_description(&mut self, property_description: String) {
    self.property_description = Some(property_description);
  }

  pub fn with_property_description(mut self, property_description: String) -> ContentModelsContentTypeProperty {
    self.property_description = Some(property_description);
    self
  }

  pub fn property_description(&self) -> Option<&String> {
    self.property_description.as_ref()
  }

  pub fn reset_property_description(&mut self) {
    self.property_description = None;
  }

  pub fn set_localizable(&mut self, localizable: bool) {
    self.localizable = Some(localizable);
  }

  pub fn with_localizable(mut self, localizable: bool) -> ContentModelsContentTypeProperty {
    self.localizable = Some(localizable);
    self
  }

  pub fn localizable(&self) -> Option<&bool> {
    self.localizable.as_ref()
  }

  pub fn reset_localizable(&mut self) {
    self.localizable = None;
  }

  pub fn set_fallback(&mut self, fallback: bool) {
    self.fallback = Some(fallback);
  }

  pub fn with_fallback(mut self, fallback: bool) -> ContentModelsContentTypeProperty {
    self.fallback = Some(fallback);
    self
  }

  pub fn fallback(&self) -> Option<&bool> {
    self.fallback.as_ref()
  }

  pub fn reset_fallback(&mut self) {
    self.fallback = None;
  }

  pub fn set_enabled(&mut self, enabled: bool) {
    self.enabled = Some(enabled);
  }

  pub fn with_enabled(mut self, enabled: bool) -> ContentModelsContentTypeProperty {
    self.enabled = Some(enabled);
    self
  }

  pub fn enabled(&self) -> Option<&bool> {
    self.enabled.as_ref()
  }

  pub fn reset_enabled(&mut self) {
    self.enabled = None;
  }

  pub fn set_order(&mut self, order: i32) {
    self.order = Some(order);
  }

  pub fn with_order(mut self, order: i32) -> ContentModelsContentTypeProperty {
    self.order = Some(order);
    self
  }

  pub fn order(&self) -> Option<&i32> {
    self.order.as_ref()
  }

  pub fn reset_order(&mut self) {
    self.order = None;
  }

  pub fn set_visible(&mut self, visible: bool) {
    self.visible = Some(visible);
  }

  pub fn with_visible(mut self, visible: bool) -> ContentModelsContentTypeProperty {
    self.visible = Some(visible);
    self
  }

  pub fn visible(&self) -> Option<&bool> {
    self.visible.as_ref()
  }

  pub fn reset_visible(&mut self) {
    self.visible = None;
  }

  pub fn set_is_title(&mut self, is_title: bool) {
    self.is_title = Some(is_title);
  }

  pub fn with_is_title(mut self, is_title: bool) -> ContentModelsContentTypeProperty {
    self.is_title = Some(is_title);
    self
  }

  pub fn is_title(&self) -> Option<&bool> {
    self.is_title.as_ref()
  }

  pub fn reset_is_title(&mut self) {
    self.is_title = None;
  }

  pub fn set_required(&mut self, required: bool) {
    self.required = Some(required);
  }

  pub fn with_required(mut self, required: bool) -> ContentModelsContentTypeProperty {
    self.required = Some(required);
    self
  }

  pub fn required(&self) -> Option<&bool> {
    self.required.as_ref()
  }

  pub fn reset_required(&mut self) {
    self.required = None;
  }

  pub fn set_max_length(&mut self, max_length: i32) {
    self.max_length = Some(max_length);
  }

  pub fn with_max_length(mut self, max_length: i32) -> ContentModelsContentTypeProperty {
    self.max_length = Some(max_length);
    self
  }

  pub fn max_length(&self) -> Option<&i32> {
    self.max_length.as_ref()
  }

  pub fn reset_max_length(&mut self) {
    self.max_length = None;
  }

  pub fn set_max_byte_length(&mut self, max_byte_length: i32) {
    self.max_byte_length = Some(max_byte_length);
  }

  pub fn with_max_byte_length(mut self, max_byte_length: i32) -> ContentModelsContentTypeProperty {
    self.max_byte_length = Some(max_byte_length);
    self
  }

  pub fn max_byte_length(&self) -> Option<&i32> {
    self.max_byte_length.as_ref()
  }

  pub fn reset_max_byte_length(&mut self) {
    self.max_byte_length = None;
  }

  pub fn set_max_file_size(&mut self, max_file_size: i32) {
    self.max_file_size = Some(max_file_size);
  }

  pub fn with_max_file_size(mut self, max_file_size: i32) -> ContentModelsContentTypeProperty {
    self.max_file_size = Some(max_file_size);
    self
  }

  pub fn max_file_size(&self) -> Option<&i32> {
    self.max_file_size.as_ref()
  }

  pub fn reset_max_file_size(&mut self) {
    self.max_file_size = None;
  }

  pub fn set_regexp(&mut self, regexp: String) {
    self.regexp = Some(regexp);
  }

  pub fn with_regexp(mut self, regexp: String) -> ContentModelsContentTypeProperty {
    self.regexp = Some(regexp);
    self
  }

  pub fn regexp(&self) -> Option<&String> {
    self.regexp.as_ref()
  }

  pub fn reset_regexp(&mut self) {
    self.regexp = None;
  }

  pub fn set_validate_as(&mut self, validate_as: String) {
    self.validate_as = Some(validate_as);
  }

  pub fn with_validate_as(mut self, validate_as: String) -> ContentModelsContentTypeProperty {
    self.validate_as = Some(validate_as);
    self
  }

  pub fn validate_as(&self) -> Option<&String> {
    self.validate_as.as_ref()
  }

  pub fn reset_validate_as(&mut self) {
    self.validate_as = None;
  }

  pub fn set_rss_attribute(&mut self, rss_attribute: String) {
    self.rss_attribute = Some(rss_attribute);
  }

  pub fn with_rss_attribute(mut self, rss_attribute: String) -> ContentModelsContentTypeProperty {
    self.rss_attribute = Some(rss_attribute);
    self
  }

  pub fn rss_attribute(&self) -> Option<&String> {
    self.rss_attribute.as_ref()
  }

  pub fn reset_rss_attribute(&mut self) {
    self.rss_attribute = None;
  }

  pub fn set_visible_dependency(&mut self, visible_dependency: String) {
    self.visible_dependency = Some(visible_dependency);
  }

  pub fn with_visible_dependency(mut self, visible_dependency: String) -> ContentModelsContentTypeProperty {
    self.visible_dependency = Some(visible_dependency);
    self
  }

  pub fn visible_dependency(&self) -> Option<&String> {
    self.visible_dependency.as_ref()
  }

  pub fn reset_visible_dependency(&mut self) {
    self.visible_dependency = None;
  }

  pub fn set_visible_on(&mut self, visible_on: String) {
    self.visible_on = Some(visible_on);
  }

  pub fn with_visible_on(mut self, visible_on: String) -> ContentModelsContentTypeProperty {
    self.visible_on = Some(visible_on);
    self
  }

  pub fn visible_on(&self) -> Option<&String> {
    self.visible_on.as_ref()
  }

  pub fn reset_visible_on(&mut self) {
    self.visible_on = None;
  }

  pub fn set_datatype(&mut self, datatype: i32) {
    self.datatype = Some(datatype);
  }

  pub fn with_datatype(mut self, datatype: i32) -> ContentModelsContentTypeProperty {
    self.datatype = Some(datatype);
    self
  }

  pub fn datatype(&self) -> Option<&i32> {
    self.datatype.as_ref()
  }

  pub fn reset_datatype(&mut self) {
    self.datatype = None;
  }

  pub fn set_attributes(&mut self, attributes: ::std::collections::HashMap<String, String>) {
    self.attributes = Some(attributes);
  }

  pub fn with_attributes(mut self, attributes: ::std::collections::HashMap<String, String>) -> ContentModelsContentTypeProperty {
    self.attributes = Some(attributes);
    self
  }

  pub fn attributes(&self) -> Option<&::std::collections::HashMap<String, String>> {
    self.attributes.as_ref()
  }

  pub fn reset_attributes(&mut self) {
    self.attributes = None;
  }

  pub fn set_child_properties(&mut self, child_properties: Vec<::models::ContentModelsContentTypeProperty>) {
    self.child_properties = Some(child_properties);
  }

  pub fn with_child_properties(mut self, child_properties: Vec<::models::ContentModelsContentTypeProperty>) -> ContentModelsContentTypeProperty {
    self.child_properties = Some(child_properties);
    self
  }

  pub fn child_properties(&self) -> Option<&Vec<::models::ContentModelsContentTypeProperty>> {
    self.child_properties.as_ref()
  }

  pub fn reset_child_properties(&mut self) {
    self.child_properties = None;
  }

  pub fn set_content_type_allowed(&mut self, content_type_allowed: String) {
    self.content_type_allowed = Some(content_type_allowed);
  }

  pub fn with_content_type_allowed(mut self, content_type_allowed: String) -> ContentModelsContentTypeProperty {
    self.content_type_allowed = Some(content_type_allowed);
    self
  }

  pub fn content_type_allowed(&self) -> Option<&String> {
    self.content_type_allowed.as_ref()
  }

  pub fn reset_content_type_allowed(&mut self) {
    self.content_type_allowed = None;
  }

  pub fn set_bind_to_property(&mut self, bind_to_property: String) {
    self.bind_to_property = Some(bind_to_property);
  }

  pub fn with_bind_to_property(mut self, bind_to_property: String) -> ContentModelsContentTypeProperty {
    self.bind_to_property = Some(bind_to_property);
    self
  }

  pub fn bind_to_property(&self) -> Option<&String> {
    self.bind_to_property.as_ref()
  }

  pub fn reset_bind_to_property(&mut self) {
    self.bind_to_property = None;
  }

  pub fn set_bound_regex(&mut self, bound_regex: String) {
    self.bound_regex = Some(bound_regex);
  }

  pub fn with_bound_regex(mut self, bound_regex: String) -> ContentModelsContentTypeProperty {
    self.bound_regex = Some(bound_regex);
    self
  }

  pub fn bound_regex(&self) -> Option<&String> {
    self.bound_regex.as_ref()
  }

  pub fn reset_bound_regex(&mut self) {
    self.bound_regex = None;
  }

  pub fn set_representation_selection(&mut self, representation_selection: ::std::collections::HashMap<String, String>) {
    self.representation_selection = Some(representation_selection);
  }

  pub fn with_representation_selection(mut self, representation_selection: ::std::collections::HashMap<String, String>) -> ContentModelsContentTypeProperty {
    self.representation_selection = Some(representation_selection);
    self
  }

  pub fn representation_selection(&self) -> Option<&::std::collections::HashMap<String, String>> {
    self.representation_selection.as_ref()
  }

  pub fn reset_representation_selection(&mut self) {
    self.representation_selection = None;
  }

  pub fn set_default_values(&mut self, default_values: Vec<::models::ContentModelsContentTypeDefaultValue>) {
    self.default_values = Some(default_values);
  }

  pub fn with_default_values(mut self, default_values: Vec<::models::ContentModelsContentTypeDefaultValue>) -> ContentModelsContentTypeProperty {
    self.default_values = Some(default_values);
    self
  }

  pub fn default_values(&self) -> Option<&Vec<::models::ContentModelsContentTypeDefaultValue>> {
    self.default_values.as_ref()
  }

  pub fn reset_default_values(&mut self) {
    self.default_values = None;
  }

  pub fn set_is_external_allowed(&mut self, is_external_allowed: bool) {
    self.is_external_allowed = Some(is_external_allowed);
  }

  pub fn with_is_external_allowed(mut self, is_external_allowed: bool) -> ContentModelsContentTypeProperty {
    self.is_external_allowed = Some(is_external_allowed);
    self
  }

  pub fn is_external_allowed(&self) -> Option<&bool> {
    self.is_external_allowed.as_ref()
  }

  pub fn reset_is_external_allowed(&mut self) {
    self.is_external_allowed = None;
  }

  pub fn set_property_section(&mut self, property_section: String) {
    self.property_section = Some(property_section);
  }

  pub fn with_property_section(mut self, property_section: String) -> ContentModelsContentTypeProperty {
    self.property_section = Some(property_section);
    self
  }

  pub fn property_section(&self) -> Option<&String> {
    self.property_section.as_ref()
  }

  pub fn reset_property_section(&mut self) {
    self.property_section = None;
  }

  pub fn set_weight(&mut self, weight: i32) {
    self.weight = Some(weight);
  }

  pub fn with_weight(mut self, weight: i32) -> ContentModelsContentTypeProperty {
    self.weight = Some(weight);
    self
  }

  pub fn weight(&self) -> Option<&i32> {
    self.weight.as_ref()
  }

  pub fn reset_weight(&mut self) {
    self.weight = None;
  }

  pub fn set_entitytype(&mut self, entitytype: String) {
    self.entitytype = Some(entitytype);
  }

  pub fn with_entitytype(mut self, entitytype: String) -> ContentModelsContentTypeProperty {
    self.entitytype = Some(entitytype);
    self
  }

  pub fn entitytype(&self) -> Option<&String> {
    self.entitytype.as_ref()
  }

  pub fn reset_entitytype(&mut self) {
    self.entitytype = None;
  }

  pub fn set_is_combo(&mut self, is_combo: bool) {
    self.is_combo = Some(is_combo);
  }

  pub fn with_is_combo(mut self, is_combo: bool) -> ContentModelsContentTypeProperty {
    self.is_combo = Some(is_combo);
    self
  }

  pub fn is_combo(&self) -> Option<&bool> {
    self.is_combo.as_ref()
  }

  pub fn reset_is_combo(&mut self) {
    self.is_combo = None;
  }

  pub fn set_suppress_property(&mut self, suppress_property: bool) {
    self.suppress_property = Some(suppress_property);
  }

  pub fn with_suppress_property(mut self, suppress_property: bool) -> ContentModelsContentTypeProperty {
    self.suppress_property = Some(suppress_property);
    self
  }

  pub fn suppress_property(&self) -> Option<&bool> {
    self.suppress_property.as_ref()
  }

  pub fn reset_suppress_property(&mut self) {
    self.suppress_property = None;
  }

  pub fn set_legal_content_types(&mut self, legal_content_types: Vec<String>) {
    self.legal_content_types = Some(legal_content_types);
  }

  pub fn with_legal_content_types(mut self, legal_content_types: Vec<String>) -> ContentModelsContentTypeProperty {
    self.legal_content_types = Some(legal_content_types);
    self
  }

  pub fn legal_content_types(&self) -> Option<&Vec<String>> {
    self.legal_content_types.as_ref()
  }

  pub fn reset_legal_content_types(&mut self) {
    self.legal_content_types = None;
  }

  pub fn set_representation_validation_string(&mut self, representation_validation_string: String) {
    self.representation_validation_string = Some(representation_validation_string);
  }

  pub fn with_representation_validation_string(mut self, representation_validation_string: String) -> ContentModelsContentTypeProperty {
    self.representation_validation_string = Some(representation_validation_string);
    self
  }

  pub fn representation_validation_string(&self) -> Option<&String> {
    self.representation_validation_string.as_ref()
  }

  pub fn reset_representation_validation_string(&mut self) {
    self.representation_validation_string = None;
  }

  pub fn set_min_width(&mut self, min_width: i32) {
    self.min_width = Some(min_width);
  }

  pub fn with_min_width(mut self, min_width: i32) -> ContentModelsContentTypeProperty {
    self.min_width = Some(min_width);
    self
  }

  pub fn min_width(&self) -> Option<&i32> {
    self.min_width.as_ref()
  }

  pub fn reset_min_width(&mut self) {
    self.min_width = None;
  }

  pub fn set_max_width(&mut self, max_width: i32) {
    self.max_width = Some(max_width);
  }

  pub fn with_max_width(mut self, max_width: i32) -> ContentModelsContentTypeProperty {
    self.max_width = Some(max_width);
    self
  }

  pub fn max_width(&self) -> Option<&i32> {
    self.max_width.as_ref()
  }

  pub fn reset_max_width(&mut self) {
    self.max_width = None;
  }

  pub fn set_min_height(&mut self, min_height: i32) {
    self.min_height = Some(min_height);
  }

  pub fn with_min_height(mut self, min_height: i32) -> ContentModelsContentTypeProperty {
    self.min_height = Some(min_height);
    self
  }

  pub fn min_height(&self) -> Option<&i32> {
    self.min_height.as_ref()
  }

  pub fn reset_min_height(&mut self) {
    self.min_height = None;
  }

  pub fn set_max_height(&mut self, max_height: i32) {
    self.max_height = Some(max_height);
  }

  pub fn with_max_height(mut self, max_height: i32) -> ContentModelsContentTypeProperty {
    self.max_height = Some(max_height);
    self
  }

  pub fn max_height(&self) -> Option<&i32> {
    self.max_height.as_ref()
  }

  pub fn reset_max_height(&mut self) {
    self.max_height = None;
  }

  pub fn set_is_video(&mut self, is_video: bool) {
    self.is_video = Some(is_video);
  }

  pub fn with_is_video(mut self, is_video: bool) -> ContentModelsContentTypeProperty {
    self.is_video = Some(is_video);
    self
  }

  pub fn is_video(&self) -> Option<&bool> {
    self.is_video.as_ref()
  }

  pub fn reset_is_video(&mut self) {
    self.is_video = None;
  }

  pub fn set_is_image(&mut self, is_image: bool) {
    self.is_image = Some(is_image);
  }

  pub fn with_is_image(mut self, is_image: bool) -> ContentModelsContentTypeProperty {
    self.is_image = Some(is_image);
    self
  }

  pub fn is_image(&self) -> Option<&bool> {
    self.is_image.as_ref()
  }

  pub fn reset_is_image(&mut self) {
    self.is_image = None;
  }

}



