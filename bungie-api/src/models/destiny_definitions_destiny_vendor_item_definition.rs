/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.7.1
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// DestinyDefinitionsDestinyVendorItemDefinition : This represents an item being sold by the vendor.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct DestinyDefinitionsDestinyVendorItemDefinition {
  /// The index into the DestinyVendorDefinition.saleList. This is what we use to refer to items being sold throughout live and definition data.
  #[serde(rename = "vendorItemIndex")]
  vendor_item_index: Option<i32>,
  /// The hash identifier of the item being sold (DestinyInventoryItemDefinition).  Note that a vendor can sell the same item in multiple ways, so don't assume that itemHash is a unique identifier for this entity.
  #[serde(rename = "itemHash")]
  item_hash: Option<i32>,
  /// The amount you will recieve of the item described in itemHash if you make the purchase.
  #[serde(rename = "quantity")]
  quantity: Option<i32>,
  /// An list of indexes into the DestinyVendorDefinition.failureStrings array, indicating the possible failure strings that can be relevant for this item.
  #[serde(rename = "failureIndexes")]
  failure_indexes: Option<Vec<i32>>,
  /// This is a pre-compiled aggregation of item value and priceOverrideList, so that we have one place to check for what the purchaser must pay for the item. Use this instead of trying to piece together the price separately.  The somewhat crappy part about this is that, now that item quantity overrides have dynamic modifiers, this will not necessarily be statically true. If you were using this instead of live data, switch to using live data.
  #[serde(rename = "currencies")]
  currencies: Option<Vec<::models::DestinyDefinitionsDestinyVendorItemQuantity>>,
  /// If this item can be refunded, this is the policy for what will be refundd, how, and in what time period.
  #[serde(rename = "refundPolicy")]
  refund_policy: Option<i32>,
  /// The amount of time before refundability of the newly purchased item will expire.
  #[serde(rename = "refundTimeLimit")]
  refund_time_limit: Option<i32>,
  /// The Default level at which the item will spawn. Almost always driven by an adjusto these days. Ideally should be singular. It's a long story how this ended up as a list, but there is always either going to be 0:1 of these entities.
  #[serde(rename = "creationLevels")]
  creation_levels: Option<Vec<::models::DestinyDefinitionsDestinyItemCreationEntryLevelDefinition>>,
  /// This is an index specifically into the display category, as opposed to the server-side Categories (which do not need to match or pair with each other in any way: server side categories are really just structures for common validation. Display Category will let us more easily categorize items visually)
  #[serde(rename = "displayCategoryIndex")]
  display_category_index: Option<i32>,
  /// The index into the DestinyVendorDefinition.categories array, so you can find the category associated with this item.
  #[serde(rename = "categoryIndex")]
  category_index: Option<i32>,
  /// Same as above, but for the original category indexes.
  #[serde(rename = "originalCategoryIndex")]
  original_category_index: Option<i32>,
  /// The minimum character level at which this item is available for sale.
  #[serde(rename = "minimumLevel")]
  minimum_level: Option<i32>,
  /// The maximum character level at which this item is available for sale.
  #[serde(rename = "maximumLevel")]
  maximum_level: Option<i32>,
  /// The action to be performed when purchasing the item, if it's not just \"buy\".
  #[serde(rename = "action")]
  action: Option<Value>,
  /// The string identifier for the category selling this item.
  #[serde(rename = "displayCategory")]
  display_category: Option<String>,
  /// The inventory bucket into which this item will be placed upon purchase.
  #[serde(rename = "inventoryBucketHash")]
  inventory_bucket_hash: Option<i32>,
  /// The most restrictive scope that determines whether the item is available in the Vendor's inventory. See DestinyGatingScope's documentation for more information.  This can be determined by Unlock gating, or by whether or not the item has purchase level requirements (minimumLevel and maximumLevel properties).
  #[serde(rename = "visibilityScope")]
  visibility_scope: Option<i32>,
  /// Similar to visibilityScope, it represents the most restrictive scope that determines whether the item can be purchased. It will at least be as restrictive as visibilityScope, but could be more restrictive if the item has additional purchase requirements beyond whether it is merely visible or not.  See DestinyGatingScope's documentation for more information.
  #[serde(rename = "purchasableScope")]
  purchasable_scope: Option<i32>,
  /// If this item can only be purchased by a given platform, this indicates the platform to which it is restricted.
  #[serde(rename = "exclusivity")]
  exclusivity: Option<i32>,
  /// If this sale can only be performed as the result of an offer check, this is true.
  #[serde(rename = "isOffer")]
  is_offer: Option<bool>,
  /// If this sale can only be performed as the result of receiving a CRM offer, this is true.
  #[serde(rename = "isCrm")]
  is_crm: Option<bool>,
  /// *if* the category this item is in supports non-default sorting, this value should represent the sorting value to use, pre-processed and ready to go.
  #[serde(rename = "sortValue")]
  sort_value: Option<i32>,
  /// If this item can expire, this is the tooltip message to show with its expiration info.
  #[serde(rename = "expirationTooltip")]
  expiration_tooltip: Option<String>,
  /// If this is populated, the purchase of this item should redirect to purchasing these other items instead.
  #[serde(rename = "redirectToSaleIndexes")]
  redirect_to_sale_indexes: Option<Vec<i32>>,
  #[serde(rename = "socketOverrides")]
  socket_overrides: Option<Vec<::models::DestinyDefinitionsDestinyVendorItemSocketOverride>>
}

impl DestinyDefinitionsDestinyVendorItemDefinition {
  /// This represents an item being sold by the vendor.
  pub fn new() -> DestinyDefinitionsDestinyVendorItemDefinition {
    DestinyDefinitionsDestinyVendorItemDefinition {
      vendor_item_index: None,
      item_hash: None,
      quantity: None,
      failure_indexes: None,
      currencies: None,
      refund_policy: None,
      refund_time_limit: None,
      creation_levels: None,
      display_category_index: None,
      category_index: None,
      original_category_index: None,
      minimum_level: None,
      maximum_level: None,
      action: None,
      display_category: None,
      inventory_bucket_hash: None,
      visibility_scope: None,
      purchasable_scope: None,
      exclusivity: None,
      is_offer: None,
      is_crm: None,
      sort_value: None,
      expiration_tooltip: None,
      redirect_to_sale_indexes: None,
      socket_overrides: None
    }
  }

  pub fn set_vendor_item_index(&mut self, vendor_item_index: i32) {
    self.vendor_item_index = Some(vendor_item_index);
  }

  pub fn with_vendor_item_index(mut self, vendor_item_index: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.vendor_item_index = Some(vendor_item_index);
    self
  }

  pub fn vendor_item_index(&self) -> Option<&i32> {
    self.vendor_item_index.as_ref()
  }

  pub fn reset_vendor_item_index(&mut self) {
    self.vendor_item_index = None;
  }

  pub fn set_item_hash(&mut self, item_hash: i32) {
    self.item_hash = Some(item_hash);
  }

  pub fn with_item_hash(mut self, item_hash: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.item_hash = Some(item_hash);
    self
  }

  pub fn item_hash(&self) -> Option<&i32> {
    self.item_hash.as_ref()
  }

  pub fn reset_item_hash(&mut self) {
    self.item_hash = None;
  }

  pub fn set_quantity(&mut self, quantity: i32) {
    self.quantity = Some(quantity);
  }

  pub fn with_quantity(mut self, quantity: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.quantity = Some(quantity);
    self
  }

  pub fn quantity(&self) -> Option<&i32> {
    self.quantity.as_ref()
  }

  pub fn reset_quantity(&mut self) {
    self.quantity = None;
  }

  pub fn set_failure_indexes(&mut self, failure_indexes: Vec<i32>) {
    self.failure_indexes = Some(failure_indexes);
  }

  pub fn with_failure_indexes(mut self, failure_indexes: Vec<i32>) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.failure_indexes = Some(failure_indexes);
    self
  }

  pub fn failure_indexes(&self) -> Option<&Vec<i32>> {
    self.failure_indexes.as_ref()
  }

  pub fn reset_failure_indexes(&mut self) {
    self.failure_indexes = None;
  }

  pub fn set_currencies(&mut self, currencies: Vec<::models::DestinyDefinitionsDestinyVendorItemQuantity>) {
    self.currencies = Some(currencies);
  }

  pub fn with_currencies(mut self, currencies: Vec<::models::DestinyDefinitionsDestinyVendorItemQuantity>) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.currencies = Some(currencies);
    self
  }

  pub fn currencies(&self) -> Option<&Vec<::models::DestinyDefinitionsDestinyVendorItemQuantity>> {
    self.currencies.as_ref()
  }

  pub fn reset_currencies(&mut self) {
    self.currencies = None;
  }

  pub fn set_refund_policy(&mut self, refund_policy: i32) {
    self.refund_policy = Some(refund_policy);
  }

  pub fn with_refund_policy(mut self, refund_policy: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.refund_policy = Some(refund_policy);
    self
  }

  pub fn refund_policy(&self) -> Option<&i32> {
    self.refund_policy.as_ref()
  }

  pub fn reset_refund_policy(&mut self) {
    self.refund_policy = None;
  }

  pub fn set_refund_time_limit(&mut self, refund_time_limit: i32) {
    self.refund_time_limit = Some(refund_time_limit);
  }

  pub fn with_refund_time_limit(mut self, refund_time_limit: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.refund_time_limit = Some(refund_time_limit);
    self
  }

  pub fn refund_time_limit(&self) -> Option<&i32> {
    self.refund_time_limit.as_ref()
  }

  pub fn reset_refund_time_limit(&mut self) {
    self.refund_time_limit = None;
  }

  pub fn set_creation_levels(&mut self, creation_levels: Vec<::models::DestinyDefinitionsDestinyItemCreationEntryLevelDefinition>) {
    self.creation_levels = Some(creation_levels);
  }

  pub fn with_creation_levels(mut self, creation_levels: Vec<::models::DestinyDefinitionsDestinyItemCreationEntryLevelDefinition>) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.creation_levels = Some(creation_levels);
    self
  }

  pub fn creation_levels(&self) -> Option<&Vec<::models::DestinyDefinitionsDestinyItemCreationEntryLevelDefinition>> {
    self.creation_levels.as_ref()
  }

  pub fn reset_creation_levels(&mut self) {
    self.creation_levels = None;
  }

  pub fn set_display_category_index(&mut self, display_category_index: i32) {
    self.display_category_index = Some(display_category_index);
  }

  pub fn with_display_category_index(mut self, display_category_index: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.display_category_index = Some(display_category_index);
    self
  }

  pub fn display_category_index(&self) -> Option<&i32> {
    self.display_category_index.as_ref()
  }

  pub fn reset_display_category_index(&mut self) {
    self.display_category_index = None;
  }

  pub fn set_category_index(&mut self, category_index: i32) {
    self.category_index = Some(category_index);
  }

  pub fn with_category_index(mut self, category_index: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.category_index = Some(category_index);
    self
  }

  pub fn category_index(&self) -> Option<&i32> {
    self.category_index.as_ref()
  }

  pub fn reset_category_index(&mut self) {
    self.category_index = None;
  }

  pub fn set_original_category_index(&mut self, original_category_index: i32) {
    self.original_category_index = Some(original_category_index);
  }

  pub fn with_original_category_index(mut self, original_category_index: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.original_category_index = Some(original_category_index);
    self
  }

  pub fn original_category_index(&self) -> Option<&i32> {
    self.original_category_index.as_ref()
  }

  pub fn reset_original_category_index(&mut self) {
    self.original_category_index = None;
  }

  pub fn set_minimum_level(&mut self, minimum_level: i32) {
    self.minimum_level = Some(minimum_level);
  }

  pub fn with_minimum_level(mut self, minimum_level: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.minimum_level = Some(minimum_level);
    self
  }

  pub fn minimum_level(&self) -> Option<&i32> {
    self.minimum_level.as_ref()
  }

  pub fn reset_minimum_level(&mut self) {
    self.minimum_level = None;
  }

  pub fn set_maximum_level(&mut self, maximum_level: i32) {
    self.maximum_level = Some(maximum_level);
  }

  pub fn with_maximum_level(mut self, maximum_level: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.maximum_level = Some(maximum_level);
    self
  }

  pub fn maximum_level(&self) -> Option<&i32> {
    self.maximum_level.as_ref()
  }

  pub fn reset_maximum_level(&mut self) {
    self.maximum_level = None;
  }

  pub fn set_action(&mut self, action: Value) {
    self.action = Some(action);
  }

  pub fn with_action(mut self, action: Value) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.action = Some(action);
    self
  }

  pub fn action(&self) -> Option<&Value> {
    self.action.as_ref()
  }

  pub fn reset_action(&mut self) {
    self.action = None;
  }

  pub fn set_display_category(&mut self, display_category: String) {
    self.display_category = Some(display_category);
  }

  pub fn with_display_category(mut self, display_category: String) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.display_category = Some(display_category);
    self
  }

  pub fn display_category(&self) -> Option<&String> {
    self.display_category.as_ref()
  }

  pub fn reset_display_category(&mut self) {
    self.display_category = None;
  }

  pub fn set_inventory_bucket_hash(&mut self, inventory_bucket_hash: i32) {
    self.inventory_bucket_hash = Some(inventory_bucket_hash);
  }

  pub fn with_inventory_bucket_hash(mut self, inventory_bucket_hash: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.inventory_bucket_hash = Some(inventory_bucket_hash);
    self
  }

  pub fn inventory_bucket_hash(&self) -> Option<&i32> {
    self.inventory_bucket_hash.as_ref()
  }

  pub fn reset_inventory_bucket_hash(&mut self) {
    self.inventory_bucket_hash = None;
  }

  pub fn set_visibility_scope(&mut self, visibility_scope: i32) {
    self.visibility_scope = Some(visibility_scope);
  }

  pub fn with_visibility_scope(mut self, visibility_scope: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.visibility_scope = Some(visibility_scope);
    self
  }

  pub fn visibility_scope(&self) -> Option<&i32> {
    self.visibility_scope.as_ref()
  }

  pub fn reset_visibility_scope(&mut self) {
    self.visibility_scope = None;
  }

  pub fn set_purchasable_scope(&mut self, purchasable_scope: i32) {
    self.purchasable_scope = Some(purchasable_scope);
  }

  pub fn with_purchasable_scope(mut self, purchasable_scope: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.purchasable_scope = Some(purchasable_scope);
    self
  }

  pub fn purchasable_scope(&self) -> Option<&i32> {
    self.purchasable_scope.as_ref()
  }

  pub fn reset_purchasable_scope(&mut self) {
    self.purchasable_scope = None;
  }

  pub fn set_exclusivity(&mut self, exclusivity: i32) {
    self.exclusivity = Some(exclusivity);
  }

  pub fn with_exclusivity(mut self, exclusivity: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.exclusivity = Some(exclusivity);
    self
  }

  pub fn exclusivity(&self) -> Option<&i32> {
    self.exclusivity.as_ref()
  }

  pub fn reset_exclusivity(&mut self) {
    self.exclusivity = None;
  }

  pub fn set_is_offer(&mut self, is_offer: bool) {
    self.is_offer = Some(is_offer);
  }

  pub fn with_is_offer(mut self, is_offer: bool) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.is_offer = Some(is_offer);
    self
  }

  pub fn is_offer(&self) -> Option<&bool> {
    self.is_offer.as_ref()
  }

  pub fn reset_is_offer(&mut self) {
    self.is_offer = None;
  }

  pub fn set_is_crm(&mut self, is_crm: bool) {
    self.is_crm = Some(is_crm);
  }

  pub fn with_is_crm(mut self, is_crm: bool) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.is_crm = Some(is_crm);
    self
  }

  pub fn is_crm(&self) -> Option<&bool> {
    self.is_crm.as_ref()
  }

  pub fn reset_is_crm(&mut self) {
    self.is_crm = None;
  }

  pub fn set_sort_value(&mut self, sort_value: i32) {
    self.sort_value = Some(sort_value);
  }

  pub fn with_sort_value(mut self, sort_value: i32) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.sort_value = Some(sort_value);
    self
  }

  pub fn sort_value(&self) -> Option<&i32> {
    self.sort_value.as_ref()
  }

  pub fn reset_sort_value(&mut self) {
    self.sort_value = None;
  }

  pub fn set_expiration_tooltip(&mut self, expiration_tooltip: String) {
    self.expiration_tooltip = Some(expiration_tooltip);
  }

  pub fn with_expiration_tooltip(mut self, expiration_tooltip: String) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.expiration_tooltip = Some(expiration_tooltip);
    self
  }

  pub fn expiration_tooltip(&self) -> Option<&String> {
    self.expiration_tooltip.as_ref()
  }

  pub fn reset_expiration_tooltip(&mut self) {
    self.expiration_tooltip = None;
  }

  pub fn set_redirect_to_sale_indexes(&mut self, redirect_to_sale_indexes: Vec<i32>) {
    self.redirect_to_sale_indexes = Some(redirect_to_sale_indexes);
  }

  pub fn with_redirect_to_sale_indexes(mut self, redirect_to_sale_indexes: Vec<i32>) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.redirect_to_sale_indexes = Some(redirect_to_sale_indexes);
    self
  }

  pub fn redirect_to_sale_indexes(&self) -> Option<&Vec<i32>> {
    self.redirect_to_sale_indexes.as_ref()
  }

  pub fn reset_redirect_to_sale_indexes(&mut self) {
    self.redirect_to_sale_indexes = None;
  }

  pub fn set_socket_overrides(&mut self, socket_overrides: Vec<::models::DestinyDefinitionsDestinyVendorItemSocketOverride>) {
    self.socket_overrides = Some(socket_overrides);
  }

  pub fn with_socket_overrides(mut self, socket_overrides: Vec<::models::DestinyDefinitionsDestinyVendorItemSocketOverride>) -> DestinyDefinitionsDestinyVendorItemDefinition {
    self.socket_overrides = Some(socket_overrides);
    self
  }

  pub fn socket_overrides(&self) -> Option<&Vec<::models::DestinyDefinitionsDestinyVendorItemSocketOverride>> {
    self.socket_overrides.as_ref()
  }

  pub fn reset_socket_overrides(&mut self) {
    self.socket_overrides = None;
  }

}



