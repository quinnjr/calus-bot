/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.7.1
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// DestinyDefinitionsDestinyItemInventoryBlockDefinition : If the item can exist in an inventory - the overwhelming majority of them can and do - then this is the basic properties regarding the item's relationship with the inventory.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct DestinyDefinitionsDestinyItemInventoryBlockDefinition {
  /// If this string is populated, you can't have more than one stack with this label in a given inventory. Note that this is different from the equipping block's unique label, which is used for equipping uniqueness.
  #[serde(rename = "stackUniqueLabel")]
  stack_unique_label: Option<String>,
  /// The maximum quantity of this item that can exist in a stack.
  #[serde(rename = "maxStackSize")]
  max_stack_size: Option<i32>,
  /// The hash identifier for the DestinyInventoryBucketDefinition to which this item belongs. I should have named this \"bucketHash\", but too many things refer to it now. Sigh.
  #[serde(rename = "bucketTypeHash")]
  bucket_type_hash: Option<i32>,
  /// If the item is picked up by the lost loot queue, this is the hash identifier for the DestinyInventoryBucketDefinition into which it will be placed. Again, I should have named this recoveryBucketHash instead.
  #[serde(rename = "recoveryBucketTypeHash")]
  recovery_bucket_type_hash: Option<i32>,
  /// The hash identifier for the Tier Type of the item, use to look up its DestinyItemTierTypeDefinition if you need to show localized data for the item's tier.
  #[serde(rename = "tierTypeHash")]
  tier_type_hash: Option<i32>,
  /// If TRUE, this item is instanced. Otherwise, it is a generic item that merely has a quantity in a stack (like Glimmer).
  #[serde(rename = "isInstanceItem")]
  is_instance_item: Option<bool>,
  /// The localized name of the tier type, which is a useful shortcut so you don't have to look up the definition every time. However, it's mostly a holdover from days before we had a DestinyItemTierTypeDefinition to refer to.
  #[serde(rename = "tierTypeName")]
  tier_type_name: Option<String>,
  /// The enumeration matching the tier type of the item to known values, again for convenience sake.
  #[serde(rename = "tierType")]
  tier_type: Option<i32>,
  /// The tooltip message to show, if any, when the item expires.
  #[serde(rename = "expirationTooltip")]
  expiration_tooltip: Option<String>,
  /// If the item expires while playing in an activity, we show a different message.
  #[serde(rename = "expiredInActivityMessage")]
  expired_in_activity_message: Option<String>,
  /// If the item expires in orbit, we show a... more different message. (\"Consummate V's, consummate!\")
  #[serde(rename = "expiredInOrbitMessage")]
  expired_in_orbit_message: Option<String>,
  #[serde(rename = "suppressExpirationWhenObjectivesComplete")]
  suppress_expiration_when_objectives_complete: Option<bool>
}

impl DestinyDefinitionsDestinyItemInventoryBlockDefinition {
  /// If the item can exist in an inventory - the overwhelming majority of them can and do - then this is the basic properties regarding the item's relationship with the inventory.
  pub fn new() -> DestinyDefinitionsDestinyItemInventoryBlockDefinition {
    DestinyDefinitionsDestinyItemInventoryBlockDefinition {
      stack_unique_label: None,
      max_stack_size: None,
      bucket_type_hash: None,
      recovery_bucket_type_hash: None,
      tier_type_hash: None,
      is_instance_item: None,
      tier_type_name: None,
      tier_type: None,
      expiration_tooltip: None,
      expired_in_activity_message: None,
      expired_in_orbit_message: None,
      suppress_expiration_when_objectives_complete: None
    }
  }

  pub fn set_stack_unique_label(&mut self, stack_unique_label: String) {
    self.stack_unique_label = Some(stack_unique_label);
  }

  pub fn with_stack_unique_label(mut self, stack_unique_label: String) -> DestinyDefinitionsDestinyItemInventoryBlockDefinition {
    self.stack_unique_label = Some(stack_unique_label);
    self
  }

  pub fn stack_unique_label(&self) -> Option<&String> {
    self.stack_unique_label.as_ref()
  }

  pub fn reset_stack_unique_label(&mut self) {
    self.stack_unique_label = None;
  }

  pub fn set_max_stack_size(&mut self, max_stack_size: i32) {
    self.max_stack_size = Some(max_stack_size);
  }

  pub fn with_max_stack_size(mut self, max_stack_size: i32) -> DestinyDefinitionsDestinyItemInventoryBlockDefinition {
    self.max_stack_size = Some(max_stack_size);
    self
  }

  pub fn max_stack_size(&self) -> Option<&i32> {
    self.max_stack_size.as_ref()
  }

  pub fn reset_max_stack_size(&mut self) {
    self.max_stack_size = None;
  }

  pub fn set_bucket_type_hash(&mut self, bucket_type_hash: i32) {
    self.bucket_type_hash = Some(bucket_type_hash);
  }

  pub fn with_bucket_type_hash(mut self, bucket_type_hash: i32) -> DestinyDefinitionsDestinyItemInventoryBlockDefinition {
    self.bucket_type_hash = Some(bucket_type_hash);
    self
  }

  pub fn bucket_type_hash(&self) -> Option<&i32> {
    self.bucket_type_hash.as_ref()
  }

  pub fn reset_bucket_type_hash(&mut self) {
    self.bucket_type_hash = None;
  }

  pub fn set_recovery_bucket_type_hash(&mut self, recovery_bucket_type_hash: i32) {
    self.recovery_bucket_type_hash = Some(recovery_bucket_type_hash);
  }

  pub fn with_recovery_bucket_type_hash(mut self, recovery_bucket_type_hash: i32) -> DestinyDefinitionsDestinyItemInventoryBlockDefinition {
    self.recovery_bucket_type_hash = Some(recovery_bucket_type_hash);
    self
  }

  pub fn recovery_bucket_type_hash(&self) -> Option<&i32> {
    self.recovery_bucket_type_hash.as_ref()
  }

  pub fn reset_recovery_bucket_type_hash(&mut self) {
    self.recovery_bucket_type_hash = None;
  }

  pub fn set_tier_type_hash(&mut self, tier_type_hash: i32) {
    self.tier_type_hash = Some(tier_type_hash);
  }

  pub fn with_tier_type_hash(mut self, tier_type_hash: i32) -> DestinyDefinitionsDestinyItemInventoryBlockDefinition {
    self.tier_type_hash = Some(tier_type_hash);
    self
  }

  pub fn tier_type_hash(&self) -> Option<&i32> {
    self.tier_type_hash.as_ref()
  }

  pub fn reset_tier_type_hash(&mut self) {
    self.tier_type_hash = None;
  }

  pub fn set_is_instance_item(&mut self, is_instance_item: bool) {
    self.is_instance_item = Some(is_instance_item);
  }

  pub fn with_is_instance_item(mut self, is_instance_item: bool) -> DestinyDefinitionsDestinyItemInventoryBlockDefinition {
    self.is_instance_item = Some(is_instance_item);
    self
  }

  pub fn is_instance_item(&self) -> Option<&bool> {
    self.is_instance_item.as_ref()
  }

  pub fn reset_is_instance_item(&mut self) {
    self.is_instance_item = None;
  }

  pub fn set_tier_type_name(&mut self, tier_type_name: String) {
    self.tier_type_name = Some(tier_type_name);
  }

  pub fn with_tier_type_name(mut self, tier_type_name: String) -> DestinyDefinitionsDestinyItemInventoryBlockDefinition {
    self.tier_type_name = Some(tier_type_name);
    self
  }

  pub fn tier_type_name(&self) -> Option<&String> {
    self.tier_type_name.as_ref()
  }

  pub fn reset_tier_type_name(&mut self) {
    self.tier_type_name = None;
  }

  pub fn set_tier_type(&mut self, tier_type: i32) {
    self.tier_type = Some(tier_type);
  }

  pub fn with_tier_type(mut self, tier_type: i32) -> DestinyDefinitionsDestinyItemInventoryBlockDefinition {
    self.tier_type = Some(tier_type);
    self
  }

  pub fn tier_type(&self) -> Option<&i32> {
    self.tier_type.as_ref()
  }

  pub fn reset_tier_type(&mut self) {
    self.tier_type = None;
  }

  pub fn set_expiration_tooltip(&mut self, expiration_tooltip: String) {
    self.expiration_tooltip = Some(expiration_tooltip);
  }

  pub fn with_expiration_tooltip(mut self, expiration_tooltip: String) -> DestinyDefinitionsDestinyItemInventoryBlockDefinition {
    self.expiration_tooltip = Some(expiration_tooltip);
    self
  }

  pub fn expiration_tooltip(&self) -> Option<&String> {
    self.expiration_tooltip.as_ref()
  }

  pub fn reset_expiration_tooltip(&mut self) {
    self.expiration_tooltip = None;
  }

  pub fn set_expired_in_activity_message(&mut self, expired_in_activity_message: String) {
    self.expired_in_activity_message = Some(expired_in_activity_message);
  }

  pub fn with_expired_in_activity_message(mut self, expired_in_activity_message: String) -> DestinyDefinitionsDestinyItemInventoryBlockDefinition {
    self.expired_in_activity_message = Some(expired_in_activity_message);
    self
  }

  pub fn expired_in_activity_message(&self) -> Option<&String> {
    self.expired_in_activity_message.as_ref()
  }

  pub fn reset_expired_in_activity_message(&mut self) {
    self.expired_in_activity_message = None;
  }

  pub fn set_expired_in_orbit_message(&mut self, expired_in_orbit_message: String) {
    self.expired_in_orbit_message = Some(expired_in_orbit_message);
  }

  pub fn with_expired_in_orbit_message(mut self, expired_in_orbit_message: String) -> DestinyDefinitionsDestinyItemInventoryBlockDefinition {
    self.expired_in_orbit_message = Some(expired_in_orbit_message);
    self
  }

  pub fn expired_in_orbit_message(&self) -> Option<&String> {
    self.expired_in_orbit_message.as_ref()
  }

  pub fn reset_expired_in_orbit_message(&mut self) {
    self.expired_in_orbit_message = None;
  }

  pub fn set_suppress_expiration_when_objectives_complete(&mut self, suppress_expiration_when_objectives_complete: bool) {
    self.suppress_expiration_when_objectives_complete = Some(suppress_expiration_when_objectives_complete);
  }

  pub fn with_suppress_expiration_when_objectives_complete(mut self, suppress_expiration_when_objectives_complete: bool) -> DestinyDefinitionsDestinyItemInventoryBlockDefinition {
    self.suppress_expiration_when_objectives_complete = Some(suppress_expiration_when_objectives_complete);
    self
  }

  pub fn suppress_expiration_when_objectives_complete(&self) -> Option<&bool> {
    self.suppress_expiration_when_objectives_complete.as_ref()
  }

  pub fn reset_suppress_expiration_when_objectives_complete(&mut self) {
    self.suppress_expiration_when_objectives_complete = None;
  }

}



