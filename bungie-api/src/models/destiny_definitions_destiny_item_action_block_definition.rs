/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.7.1
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// DestinyDefinitionsDestinyItemActionBlockDefinition : If an item can have an action performed on it (like \"Dismantle\"), it will be defined here if you care.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct DestinyDefinitionsDestinyItemActionBlockDefinition {
  /// Localized text for the verb of the action being performed.
  #[serde(rename = "verbName")]
  verb_name: Option<String>,
  /// Localized text describing the action being performed.
  #[serde(rename = "verbDescription")]
  verb_description: Option<String>,
  /// The content has this property, however it's not entirely clear how it is used.
  #[serde(rename = "isPositive")]
  is_positive: Option<bool>,
  /// If the action has an overlay screen associated with it, this is the name of that screen. Unfortunately, we cannot return the screen's data itself.
  #[serde(rename = "overlayScreenName")]
  overlay_screen_name: Option<String>,
  /// The icon associated with the overlay screen for the action, if any.
  #[serde(rename = "overlayIcon")]
  overlay_icon: Option<String>,
  /// The number of seconds to delay before allowing this action to be performed again.
  #[serde(rename = "requiredCooldownSeconds")]
  required_cooldown_seconds: Option<i32>,
  /// If the action requires other items to exist or be destroyed, this is the list of those items and requirements.
  #[serde(rename = "requiredItems")]
  required_items: Option<Vec<::models::DestinyDefinitionsDestinyItemActionRequiredItemDefinition>>,
  /// If performing this action earns you Progression, this is the list of progressions and values granted for those progressions by performing this action.
  #[serde(rename = "progressionRewards")]
  progression_rewards: Option<Vec<::models::DestinyDefinitionsDestinyProgressionRewardDefinition>>,
  /// The internal identifier for the action.
  #[serde(rename = "actionTypeLabel")]
  action_type_label: Option<String>,
  /// Theoretically, an item could have a localized string for a hint about the location in which the action should be performed. In practice, no items yet have this property.
  #[serde(rename = "requiredLocation")]
  required_location: Option<String>,
  /// The identifier hash for the Cooldown associated with this action. We have not pulled this data yet for you to have more data to use for cooldowns.
  #[serde(rename = "requiredCooldownHash")]
  required_cooldown_hash: Option<i32>,
  /// If true, the item is deleted when the action completes.
  #[serde(rename = "deleteOnAction")]
  delete_on_action: Option<bool>,
  /// If true, the entire stack is deleted when the action completes.
  #[serde(rename = "consumeEntireStack")]
  consume_entire_stack: Option<bool>,
  /// If true, this action will be performed as soon as you earn this item. Some rewards work this way, providing you a single item to pick up from a reward-granting vendor in-game and then immediately consuming itself to provide you multiple items.
  #[serde(rename = "useOnAcquire")]
  use_on_acquire: Option<bool>
}

impl DestinyDefinitionsDestinyItemActionBlockDefinition {
  /// If an item can have an action performed on it (like \"Dismantle\"), it will be defined here if you care.
  pub fn new() -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    DestinyDefinitionsDestinyItemActionBlockDefinition {
      verb_name: None,
      verb_description: None,
      is_positive: None,
      overlay_screen_name: None,
      overlay_icon: None,
      required_cooldown_seconds: None,
      required_items: None,
      progression_rewards: None,
      action_type_label: None,
      required_location: None,
      required_cooldown_hash: None,
      delete_on_action: None,
      consume_entire_stack: None,
      use_on_acquire: None
    }
  }

  pub fn set_verb_name(&mut self, verb_name: String) {
    self.verb_name = Some(verb_name);
  }

  pub fn with_verb_name(mut self, verb_name: String) -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    self.verb_name = Some(verb_name);
    self
  }

  pub fn verb_name(&self) -> Option<&String> {
    self.verb_name.as_ref()
  }

  pub fn reset_verb_name(&mut self) {
    self.verb_name = None;
  }

  pub fn set_verb_description(&mut self, verb_description: String) {
    self.verb_description = Some(verb_description);
  }

  pub fn with_verb_description(mut self, verb_description: String) -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    self.verb_description = Some(verb_description);
    self
  }

  pub fn verb_description(&self) -> Option<&String> {
    self.verb_description.as_ref()
  }

  pub fn reset_verb_description(&mut self) {
    self.verb_description = None;
  }

  pub fn set_is_positive(&mut self, is_positive: bool) {
    self.is_positive = Some(is_positive);
  }

  pub fn with_is_positive(mut self, is_positive: bool) -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    self.is_positive = Some(is_positive);
    self
  }

  pub fn is_positive(&self) -> Option<&bool> {
    self.is_positive.as_ref()
  }

  pub fn reset_is_positive(&mut self) {
    self.is_positive = None;
  }

  pub fn set_overlay_screen_name(&mut self, overlay_screen_name: String) {
    self.overlay_screen_name = Some(overlay_screen_name);
  }

  pub fn with_overlay_screen_name(mut self, overlay_screen_name: String) -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    self.overlay_screen_name = Some(overlay_screen_name);
    self
  }

  pub fn overlay_screen_name(&self) -> Option<&String> {
    self.overlay_screen_name.as_ref()
  }

  pub fn reset_overlay_screen_name(&mut self) {
    self.overlay_screen_name = None;
  }

  pub fn set_overlay_icon(&mut self, overlay_icon: String) {
    self.overlay_icon = Some(overlay_icon);
  }

  pub fn with_overlay_icon(mut self, overlay_icon: String) -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    self.overlay_icon = Some(overlay_icon);
    self
  }

  pub fn overlay_icon(&self) -> Option<&String> {
    self.overlay_icon.as_ref()
  }

  pub fn reset_overlay_icon(&mut self) {
    self.overlay_icon = None;
  }

  pub fn set_required_cooldown_seconds(&mut self, required_cooldown_seconds: i32) {
    self.required_cooldown_seconds = Some(required_cooldown_seconds);
  }

  pub fn with_required_cooldown_seconds(mut self, required_cooldown_seconds: i32) -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    self.required_cooldown_seconds = Some(required_cooldown_seconds);
    self
  }

  pub fn required_cooldown_seconds(&self) -> Option<&i32> {
    self.required_cooldown_seconds.as_ref()
  }

  pub fn reset_required_cooldown_seconds(&mut self) {
    self.required_cooldown_seconds = None;
  }

  pub fn set_required_items(&mut self, required_items: Vec<::models::DestinyDefinitionsDestinyItemActionRequiredItemDefinition>) {
    self.required_items = Some(required_items);
  }

  pub fn with_required_items(mut self, required_items: Vec<::models::DestinyDefinitionsDestinyItemActionRequiredItemDefinition>) -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    self.required_items = Some(required_items);
    self
  }

  pub fn required_items(&self) -> Option<&Vec<::models::DestinyDefinitionsDestinyItemActionRequiredItemDefinition>> {
    self.required_items.as_ref()
  }

  pub fn reset_required_items(&mut self) {
    self.required_items = None;
  }

  pub fn set_progression_rewards(&mut self, progression_rewards: Vec<::models::DestinyDefinitionsDestinyProgressionRewardDefinition>) {
    self.progression_rewards = Some(progression_rewards);
  }

  pub fn with_progression_rewards(mut self, progression_rewards: Vec<::models::DestinyDefinitionsDestinyProgressionRewardDefinition>) -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    self.progression_rewards = Some(progression_rewards);
    self
  }

  pub fn progression_rewards(&self) -> Option<&Vec<::models::DestinyDefinitionsDestinyProgressionRewardDefinition>> {
    self.progression_rewards.as_ref()
  }

  pub fn reset_progression_rewards(&mut self) {
    self.progression_rewards = None;
  }

  pub fn set_action_type_label(&mut self, action_type_label: String) {
    self.action_type_label = Some(action_type_label);
  }

  pub fn with_action_type_label(mut self, action_type_label: String) -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    self.action_type_label = Some(action_type_label);
    self
  }

  pub fn action_type_label(&self) -> Option<&String> {
    self.action_type_label.as_ref()
  }

  pub fn reset_action_type_label(&mut self) {
    self.action_type_label = None;
  }

  pub fn set_required_location(&mut self, required_location: String) {
    self.required_location = Some(required_location);
  }

  pub fn with_required_location(mut self, required_location: String) -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    self.required_location = Some(required_location);
    self
  }

  pub fn required_location(&self) -> Option<&String> {
    self.required_location.as_ref()
  }

  pub fn reset_required_location(&mut self) {
    self.required_location = None;
  }

  pub fn set_required_cooldown_hash(&mut self, required_cooldown_hash: i32) {
    self.required_cooldown_hash = Some(required_cooldown_hash);
  }

  pub fn with_required_cooldown_hash(mut self, required_cooldown_hash: i32) -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    self.required_cooldown_hash = Some(required_cooldown_hash);
    self
  }

  pub fn required_cooldown_hash(&self) -> Option<&i32> {
    self.required_cooldown_hash.as_ref()
  }

  pub fn reset_required_cooldown_hash(&mut self) {
    self.required_cooldown_hash = None;
  }

  pub fn set_delete_on_action(&mut self, delete_on_action: bool) {
    self.delete_on_action = Some(delete_on_action);
  }

  pub fn with_delete_on_action(mut self, delete_on_action: bool) -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    self.delete_on_action = Some(delete_on_action);
    self
  }

  pub fn delete_on_action(&self) -> Option<&bool> {
    self.delete_on_action.as_ref()
  }

  pub fn reset_delete_on_action(&mut self) {
    self.delete_on_action = None;
  }

  pub fn set_consume_entire_stack(&mut self, consume_entire_stack: bool) {
    self.consume_entire_stack = Some(consume_entire_stack);
  }

  pub fn with_consume_entire_stack(mut self, consume_entire_stack: bool) -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    self.consume_entire_stack = Some(consume_entire_stack);
    self
  }

  pub fn consume_entire_stack(&self) -> Option<&bool> {
    self.consume_entire_stack.as_ref()
  }

  pub fn reset_consume_entire_stack(&mut self) {
    self.consume_entire_stack = None;
  }

  pub fn set_use_on_acquire(&mut self, use_on_acquire: bool) {
    self.use_on_acquire = Some(use_on_acquire);
  }

  pub fn with_use_on_acquire(mut self, use_on_acquire: bool) -> DestinyDefinitionsDestinyItemActionBlockDefinition {
    self.use_on_acquire = Some(use_on_acquire);
    self
  }

  pub fn use_on_acquire(&self) -> Option<&bool> {
    self.use_on_acquire.as_ref()
  }

  pub fn reset_use_on_acquire(&mut self) {
    self.use_on_acquire = None;
  }

}



