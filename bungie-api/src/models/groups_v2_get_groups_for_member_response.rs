/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.7.1
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct GroupsV2GetGroupsForMemberResponse {
  /// A convenience property that indicates if every membership this user has that is a part of this group are part of an account that is considered inactive - for example, overridden accounts in Cross Save.   The key is the Group ID for the group being checked, and the value is true if the users' memberships for that group are all inactive.
  #[serde(rename = "areAllMembershipsInactive")]
  are_all_memberships_inactive: Option<::std::collections::HashMap<String, bool>>,
  #[serde(rename = "results")]
  results: Option<Vec<::models::GroupsV2GroupMembership>>,
  #[serde(rename = "totalResults")]
  total_results: Option<i32>,
  #[serde(rename = "hasMore")]
  has_more: Option<bool>,
  #[serde(rename = "query")]
  query: Option<::models::QueriesPagedQuery>,
  #[serde(rename = "replacementContinuationToken")]
  replacement_continuation_token: Option<String>,
  /// If useTotalResults is true, then totalResults represents an accurate count.  If False, it does not, and may be estimated/only the size of the current page.  Either way, you should probably always only trust hasMore.  This is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.
  #[serde(rename = "useTotalResults")]
  use_total_results: Option<bool>
}

impl GroupsV2GetGroupsForMemberResponse {
  pub fn new() -> GroupsV2GetGroupsForMemberResponse {
    GroupsV2GetGroupsForMemberResponse {
      are_all_memberships_inactive: None,
      results: None,
      total_results: None,
      has_more: None,
      query: None,
      replacement_continuation_token: None,
      use_total_results: None
    }
  }

  pub fn set_are_all_memberships_inactive(&mut self, are_all_memberships_inactive: ::std::collections::HashMap<String, bool>) {
    self.are_all_memberships_inactive = Some(are_all_memberships_inactive);
  }

  pub fn with_are_all_memberships_inactive(mut self, are_all_memberships_inactive: ::std::collections::HashMap<String, bool>) -> GroupsV2GetGroupsForMemberResponse {
    self.are_all_memberships_inactive = Some(are_all_memberships_inactive);
    self
  }

  pub fn are_all_memberships_inactive(&self) -> Option<&::std::collections::HashMap<String, bool>> {
    self.are_all_memberships_inactive.as_ref()
  }

  pub fn reset_are_all_memberships_inactive(&mut self) {
    self.are_all_memberships_inactive = None;
  }

  pub fn set_results(&mut self, results: Vec<::models::GroupsV2GroupMembership>) {
    self.results = Some(results);
  }

  pub fn with_results(mut self, results: Vec<::models::GroupsV2GroupMembership>) -> GroupsV2GetGroupsForMemberResponse {
    self.results = Some(results);
    self
  }

  pub fn results(&self) -> Option<&Vec<::models::GroupsV2GroupMembership>> {
    self.results.as_ref()
  }

  pub fn reset_results(&mut self) {
    self.results = None;
  }

  pub fn set_total_results(&mut self, total_results: i32) {
    self.total_results = Some(total_results);
  }

  pub fn with_total_results(mut self, total_results: i32) -> GroupsV2GetGroupsForMemberResponse {
    self.total_results = Some(total_results);
    self
  }

  pub fn total_results(&self) -> Option<&i32> {
    self.total_results.as_ref()
  }

  pub fn reset_total_results(&mut self) {
    self.total_results = None;
  }

  pub fn set_has_more(&mut self, has_more: bool) {
    self.has_more = Some(has_more);
  }

  pub fn with_has_more(mut self, has_more: bool) -> GroupsV2GetGroupsForMemberResponse {
    self.has_more = Some(has_more);
    self
  }

  pub fn has_more(&self) -> Option<&bool> {
    self.has_more.as_ref()
  }

  pub fn reset_has_more(&mut self) {
    self.has_more = None;
  }

  pub fn set_query(&mut self, query: ::models::QueriesPagedQuery) {
    self.query = Some(query);
  }

  pub fn with_query(mut self, query: ::models::QueriesPagedQuery) -> GroupsV2GetGroupsForMemberResponse {
    self.query = Some(query);
    self
  }

  pub fn query(&self) -> Option<&::models::QueriesPagedQuery> {
    self.query.as_ref()
  }

  pub fn reset_query(&mut self) {
    self.query = None;
  }

  pub fn set_replacement_continuation_token(&mut self, replacement_continuation_token: String) {
    self.replacement_continuation_token = Some(replacement_continuation_token);
  }

  pub fn with_replacement_continuation_token(mut self, replacement_continuation_token: String) -> GroupsV2GetGroupsForMemberResponse {
    self.replacement_continuation_token = Some(replacement_continuation_token);
    self
  }

  pub fn replacement_continuation_token(&self) -> Option<&String> {
    self.replacement_continuation_token.as_ref()
  }

  pub fn reset_replacement_continuation_token(&mut self) {
    self.replacement_continuation_token = None;
  }

  pub fn set_use_total_results(&mut self, use_total_results: bool) {
    self.use_total_results = Some(use_total_results);
  }

  pub fn with_use_total_results(mut self, use_total_results: bool) -> GroupsV2GetGroupsForMemberResponse {
    self.use_total_results = Some(use_total_results);
    self
  }

  pub fn use_total_results(&self) -> Option<&bool> {
    self.use_total_results.as_ref()
  }

  pub fn reset_use_total_results(&mut self) {
    self.use_total_results = None;
  }

}



