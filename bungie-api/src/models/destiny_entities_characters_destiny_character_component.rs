/* 
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * OpenAPI spec version: 2.7.1
 * Contact: support@bungie.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// DestinyEntitiesCharactersDestinyCharacterComponent : This component contains base properties of the character. You'll probably want to always request this component, but hey you do you.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct DestinyEntitiesCharactersDestinyCharacterComponent {
  /// Every Destiny Profile has a membershipId. This is provided on the character as well for convenience.
  #[serde(rename = "membershipId")]
  membership_id: Option<i64>,
  /// membershipType tells you the platform on which the character plays. Examine the BungieMembershipType enumeration for possible values.
  #[serde(rename = "membershipType")]
  membership_type: Option<i32>,
  /// The unique identifier for the character.
  #[serde(rename = "characterId")]
  character_id: Option<i64>,
  /// The last date that the user played Destiny.
  #[serde(rename = "dateLastPlayed")]
  date_last_played: Option<String>,
  /// If the user is currently playing, this is how long they've been playing.
  #[serde(rename = "minutesPlayedThisSession")]
  minutes_played_this_session: Option<i64>,
  /// If this value is 525,600, then they played Destiny for a year. Or they're a very dedicated Rent fan. Note that this includes idle time, not just time spent actually in activities shooting things.
  #[serde(rename = "minutesPlayedTotal")]
  minutes_played_total: Option<i64>,
  /// The user's calculated \"Light Level\". Light level is an indicator of your power that mostly matters in the end game, once you've reached the maximum character level: it's a level that's dependent on the average Attack/Defense power of your items.
  #[serde(rename = "light")]
  light: Option<i32>,
  /// Your character's stats, such as Agility, Resilience, etc... *not* historical stats.  You'll have to call a different endpoint for those.
  #[serde(rename = "stats")]
  stats: Option<::std::collections::HashMap<String, i32>>,
  /// Use this hash to look up the character's DestinyRaceDefinition.
  #[serde(rename = "raceHash")]
  race_hash: Option<i32>,
  /// Use this hash to look up the character's DestinyGenderDefinition.
  #[serde(rename = "genderHash")]
  gender_hash: Option<i32>,
  /// Use this hash to look up the character's DestinyClassDefinition.
  #[serde(rename = "classHash")]
  class_hash: Option<i32>,
  /// Mostly for historical purposes at this point, this is an enumeration for the character's race.  It'll be preferable in the general case to look up the related definition: but for some people this was too convenient to remove.
  #[serde(rename = "raceType")]
  race_type: Option<i32>,
  /// Mostly for historical purposes at this point, this is an enumeration for the character's class.  It'll be preferable in the general case to look up the related definition: but for some people this was too convenient to remove.
  #[serde(rename = "classType")]
  class_type: Option<i32>,
  /// Mostly for historical purposes at this point, this is an enumeration for the character's Gender.  It'll be preferable in the general case to look up the related definition: but for some people this was too convenient to remove. And yeah, it's an enumeration and not a boolean. Fight me.
  #[serde(rename = "genderType")]
  gender_type: Option<i32>,
  /// A shortcut path to the user's currently equipped emblem image. If you're just showing summary info for a user, this is more convenient than examining their equipped emblem and looking up the definition.
  #[serde(rename = "emblemPath")]
  emblem_path: Option<String>,
  /// A shortcut path to the user's currently equipped emblem background image. If you're just showing summary info for a user, this is more convenient than examining their equipped emblem and looking up the definition.
  #[serde(rename = "emblemBackgroundPath")]
  emblem_background_path: Option<String>,
  /// The hash of the currently equipped emblem for the user. Can be used to look up the DestinyInventoryItemDefinition.
  #[serde(rename = "emblemHash")]
  emblem_hash: Option<i32>,
  /// A shortcut for getting the background color of the user's currently equipped emblem without having to do a DestinyInventoryItemDefinition lookup.
  #[serde(rename = "emblemColor")]
  emblem_color: Option<Value>,
  /// The progression that indicates your character's level. Not their light level, but their character level: you know, the thing you max out a couple hours in and then ignore for the sake of light level.
  #[serde(rename = "levelProgression")]
  level_progression: Option<Value>,
  /// The \"base\" level of your character, not accounting for any light level.
  #[serde(rename = "baseCharacterLevel")]
  base_character_level: Option<i32>,
  /// A number between 0 and 100, indicating the whole and fractional % remaining to get to the next character level.
  #[serde(rename = "percentToNextLevel")]
  percent_to_next_level: Option<f32>,
  /// If this Character has a title assigned to it, this is the identifier of the DestinyRecordDefinition that has that title information.
  #[serde(rename = "titleRecordHash")]
  title_record_hash: Option<i32>
}

impl DestinyEntitiesCharactersDestinyCharacterComponent {
  /// This component contains base properties of the character. You'll probably want to always request this component, but hey you do you.
  pub fn new() -> DestinyEntitiesCharactersDestinyCharacterComponent {
    DestinyEntitiesCharactersDestinyCharacterComponent {
      membership_id: None,
      membership_type: None,
      character_id: None,
      date_last_played: None,
      minutes_played_this_session: None,
      minutes_played_total: None,
      light: None,
      stats: None,
      race_hash: None,
      gender_hash: None,
      class_hash: None,
      race_type: None,
      class_type: None,
      gender_type: None,
      emblem_path: None,
      emblem_background_path: None,
      emblem_hash: None,
      emblem_color: None,
      level_progression: None,
      base_character_level: None,
      percent_to_next_level: None,
      title_record_hash: None
    }
  }

  pub fn set_membership_id(&mut self, membership_id: i64) {
    self.membership_id = Some(membership_id);
  }

  pub fn with_membership_id(mut self, membership_id: i64) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.membership_id = Some(membership_id);
    self
  }

  pub fn membership_id(&self) -> Option<&i64> {
    self.membership_id.as_ref()
  }

  pub fn reset_membership_id(&mut self) {
    self.membership_id = None;
  }

  pub fn set_membership_type(&mut self, membership_type: i32) {
    self.membership_type = Some(membership_type);
  }

  pub fn with_membership_type(mut self, membership_type: i32) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.membership_type = Some(membership_type);
    self
  }

  pub fn membership_type(&self) -> Option<&i32> {
    self.membership_type.as_ref()
  }

  pub fn reset_membership_type(&mut self) {
    self.membership_type = None;
  }

  pub fn set_character_id(&mut self, character_id: i64) {
    self.character_id = Some(character_id);
  }

  pub fn with_character_id(mut self, character_id: i64) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.character_id = Some(character_id);
    self
  }

  pub fn character_id(&self) -> Option<&i64> {
    self.character_id.as_ref()
  }

  pub fn reset_character_id(&mut self) {
    self.character_id = None;
  }

  pub fn set_date_last_played(&mut self, date_last_played: String) {
    self.date_last_played = Some(date_last_played);
  }

  pub fn with_date_last_played(mut self, date_last_played: String) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.date_last_played = Some(date_last_played);
    self
  }

  pub fn date_last_played(&self) -> Option<&String> {
    self.date_last_played.as_ref()
  }

  pub fn reset_date_last_played(&mut self) {
    self.date_last_played = None;
  }

  pub fn set_minutes_played_this_session(&mut self, minutes_played_this_session: i64) {
    self.minutes_played_this_session = Some(minutes_played_this_session);
  }

  pub fn with_minutes_played_this_session(mut self, minutes_played_this_session: i64) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.minutes_played_this_session = Some(minutes_played_this_session);
    self
  }

  pub fn minutes_played_this_session(&self) -> Option<&i64> {
    self.minutes_played_this_session.as_ref()
  }

  pub fn reset_minutes_played_this_session(&mut self) {
    self.minutes_played_this_session = None;
  }

  pub fn set_minutes_played_total(&mut self, minutes_played_total: i64) {
    self.minutes_played_total = Some(minutes_played_total);
  }

  pub fn with_minutes_played_total(mut self, minutes_played_total: i64) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.minutes_played_total = Some(minutes_played_total);
    self
  }

  pub fn minutes_played_total(&self) -> Option<&i64> {
    self.minutes_played_total.as_ref()
  }

  pub fn reset_minutes_played_total(&mut self) {
    self.minutes_played_total = None;
  }

  pub fn set_light(&mut self, light: i32) {
    self.light = Some(light);
  }

  pub fn with_light(mut self, light: i32) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.light = Some(light);
    self
  }

  pub fn light(&self) -> Option<&i32> {
    self.light.as_ref()
  }

  pub fn reset_light(&mut self) {
    self.light = None;
  }

  pub fn set_stats(&mut self, stats: ::std::collections::HashMap<String, i32>) {
    self.stats = Some(stats);
  }

  pub fn with_stats(mut self, stats: ::std::collections::HashMap<String, i32>) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.stats = Some(stats);
    self
  }

  pub fn stats(&self) -> Option<&::std::collections::HashMap<String, i32>> {
    self.stats.as_ref()
  }

  pub fn reset_stats(&mut self) {
    self.stats = None;
  }

  pub fn set_race_hash(&mut self, race_hash: i32) {
    self.race_hash = Some(race_hash);
  }

  pub fn with_race_hash(mut self, race_hash: i32) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.race_hash = Some(race_hash);
    self
  }

  pub fn race_hash(&self) -> Option<&i32> {
    self.race_hash.as_ref()
  }

  pub fn reset_race_hash(&mut self) {
    self.race_hash = None;
  }

  pub fn set_gender_hash(&mut self, gender_hash: i32) {
    self.gender_hash = Some(gender_hash);
  }

  pub fn with_gender_hash(mut self, gender_hash: i32) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.gender_hash = Some(gender_hash);
    self
  }

  pub fn gender_hash(&self) -> Option<&i32> {
    self.gender_hash.as_ref()
  }

  pub fn reset_gender_hash(&mut self) {
    self.gender_hash = None;
  }

  pub fn set_class_hash(&mut self, class_hash: i32) {
    self.class_hash = Some(class_hash);
  }

  pub fn with_class_hash(mut self, class_hash: i32) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.class_hash = Some(class_hash);
    self
  }

  pub fn class_hash(&self) -> Option<&i32> {
    self.class_hash.as_ref()
  }

  pub fn reset_class_hash(&mut self) {
    self.class_hash = None;
  }

  pub fn set_race_type(&mut self, race_type: i32) {
    self.race_type = Some(race_type);
  }

  pub fn with_race_type(mut self, race_type: i32) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.race_type = Some(race_type);
    self
  }

  pub fn race_type(&self) -> Option<&i32> {
    self.race_type.as_ref()
  }

  pub fn reset_race_type(&mut self) {
    self.race_type = None;
  }

  pub fn set_class_type(&mut self, class_type: i32) {
    self.class_type = Some(class_type);
  }

  pub fn with_class_type(mut self, class_type: i32) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.class_type = Some(class_type);
    self
  }

  pub fn class_type(&self) -> Option<&i32> {
    self.class_type.as_ref()
  }

  pub fn reset_class_type(&mut self) {
    self.class_type = None;
  }

  pub fn set_gender_type(&mut self, gender_type: i32) {
    self.gender_type = Some(gender_type);
  }

  pub fn with_gender_type(mut self, gender_type: i32) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.gender_type = Some(gender_type);
    self
  }

  pub fn gender_type(&self) -> Option<&i32> {
    self.gender_type.as_ref()
  }

  pub fn reset_gender_type(&mut self) {
    self.gender_type = None;
  }

  pub fn set_emblem_path(&mut self, emblem_path: String) {
    self.emblem_path = Some(emblem_path);
  }

  pub fn with_emblem_path(mut self, emblem_path: String) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.emblem_path = Some(emblem_path);
    self
  }

  pub fn emblem_path(&self) -> Option<&String> {
    self.emblem_path.as_ref()
  }

  pub fn reset_emblem_path(&mut self) {
    self.emblem_path = None;
  }

  pub fn set_emblem_background_path(&mut self, emblem_background_path: String) {
    self.emblem_background_path = Some(emblem_background_path);
  }

  pub fn with_emblem_background_path(mut self, emblem_background_path: String) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.emblem_background_path = Some(emblem_background_path);
    self
  }

  pub fn emblem_background_path(&self) -> Option<&String> {
    self.emblem_background_path.as_ref()
  }

  pub fn reset_emblem_background_path(&mut self) {
    self.emblem_background_path = None;
  }

  pub fn set_emblem_hash(&mut self, emblem_hash: i32) {
    self.emblem_hash = Some(emblem_hash);
  }

  pub fn with_emblem_hash(mut self, emblem_hash: i32) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.emblem_hash = Some(emblem_hash);
    self
  }

  pub fn emblem_hash(&self) -> Option<&i32> {
    self.emblem_hash.as_ref()
  }

  pub fn reset_emblem_hash(&mut self) {
    self.emblem_hash = None;
  }

  pub fn set_emblem_color(&mut self, emblem_color: Value) {
    self.emblem_color = Some(emblem_color);
  }

  pub fn with_emblem_color(mut self, emblem_color: Value) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.emblem_color = Some(emblem_color);
    self
  }

  pub fn emblem_color(&self) -> Option<&Value> {
    self.emblem_color.as_ref()
  }

  pub fn reset_emblem_color(&mut self) {
    self.emblem_color = None;
  }

  pub fn set_level_progression(&mut self, level_progression: Value) {
    self.level_progression = Some(level_progression);
  }

  pub fn with_level_progression(mut self, level_progression: Value) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.level_progression = Some(level_progression);
    self
  }

  pub fn level_progression(&self) -> Option<&Value> {
    self.level_progression.as_ref()
  }

  pub fn reset_level_progression(&mut self) {
    self.level_progression = None;
  }

  pub fn set_base_character_level(&mut self, base_character_level: i32) {
    self.base_character_level = Some(base_character_level);
  }

  pub fn with_base_character_level(mut self, base_character_level: i32) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.base_character_level = Some(base_character_level);
    self
  }

  pub fn base_character_level(&self) -> Option<&i32> {
    self.base_character_level.as_ref()
  }

  pub fn reset_base_character_level(&mut self) {
    self.base_character_level = None;
  }

  pub fn set_percent_to_next_level(&mut self, percent_to_next_level: f32) {
    self.percent_to_next_level = Some(percent_to_next_level);
  }

  pub fn with_percent_to_next_level(mut self, percent_to_next_level: f32) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.percent_to_next_level = Some(percent_to_next_level);
    self
  }

  pub fn percent_to_next_level(&self) -> Option<&f32> {
    self.percent_to_next_level.as_ref()
  }

  pub fn reset_percent_to_next_level(&mut self) {
    self.percent_to_next_level = None;
  }

  pub fn set_title_record_hash(&mut self, title_record_hash: i32) {
    self.title_record_hash = Some(title_record_hash);
  }

  pub fn with_title_record_hash(mut self, title_record_hash: i32) -> DestinyEntitiesCharactersDestinyCharacterComponent {
    self.title_record_hash = Some(title_record_hash);
    self
  }

  pub fn title_record_hash(&self) -> Option<&i32> {
    self.title_record_hash.as_ref()
  }

  pub fn reset_title_record_hash(&mut self) {
    self.title_record_hash = None;
  }

}



